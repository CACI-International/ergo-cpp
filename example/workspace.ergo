std:import {fs, match, script, seq, Iter, Path} = std:

c++ = ergo ..
project-root = std:source:dir ()
build = fn :toolchain :p -> {
    # Load requested output
    output = ergo <| Path:join :project-root :p
    c++:get-output {project-root, toolchain} :output
}
dist = fn :result -> {
    out = Path:join :project-root dist
    fs:remove :out
    fs:create-dir :out
    fs:copy result:file :out
    Iter:map (fn :f -> fs:copy :f :out) result:runtime
    ()
}

debug-toolchain = c++:toolchain {
    compile-flags = [-Og, -g]
    link-flags = [-Og]
}

release-toolchain = c++:toolchain {
    compile-flags = [-O2]
    link-flags = [-O2, -s]
}

debug = fn :p -> dist <| build :debug-toolchain :p
release = fn :p -> dist <| build :release-toolchain :p
run = fn :p -> c++:exec-output <| build :debug-toolchain :p

write-commands = fn :result -> fs:copy (c++:compile-commands :result) :project-root

command = match:value [
    fn debug :p -> debug :p
    fn release :p -> release :p
    fn run :p -> run :p
    fn compile-commands debug :p -> write-commands <| build :debug-toolchain :p
    fn compile-commands release :p -> write-commands <| build :release-toolchain :p
]

{command, c++}
