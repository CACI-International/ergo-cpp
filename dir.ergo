# The c++ module provides an abstraction over c++ compilation and linking ()
# This module assumes binaries that are compatible with gcc flags (typically gcc and clang).

std:import {
    cache, default, env, exec, fs, if, match, task
    Array, Bool, Error, Iter, Map, Path, String, Unset 
} = :std

log = std:log:sublog c++

script-dir = std:source:dir ()

## Return the value of an environment variable, or an alternative value if not set.
env-or = fn :name :alternative -> default (env:get :name) as :alternative

## Run an exec result as a task (counting as one task).
run = fn :description :result -> task (count = 1) :description result:complete

# TODO divorce the linking/native/binutils stuff from c/c++, separate c and c++ into separate
# libraries

os-libpath-env = fn :os -> match :os [
    linux -> LD_LIBRARY_PATH
    std:bind:or macos ios -> DYLD_LIBRARY_PATH
    _ -> PATH
]

system-path-separator = match std:env:os [windows -> ";", _ -> ":"]

system-libpath-env = os-libpath-env std:env:os

split-paths = fn (default :paths as "") -> (:paths | String:split :system-path-separator | Iter:map Path:from | Array:from)

join-paths = fn (Array:Of :Path |> :paths) -> String:join :system-path-separator <| Iter:map String:from :paths

## Create a toolchain from the given configuration.
##
## Arguments: `(Map :config)`
## 
## The `config` may contain the following optional keys:
## * `paths` - Search paths containing the toolchain, defaults to the current `PATH`.
## * `library-paths` - Search paths for library files for the toolchain, defaults to the current
## (os-specific) library path.
## * `target-triple` - The target triple prefix to use when searching for tools.
## * `override` - Overridden names or paths of tools.
## * `compile-flags` - Flags to always pass to the C++ compiler when compiling source code.
## * `c-compile-flags` - Flags to always pass to the C compiler when compiling C source code.
## * `link-flags` - Flags to always pass to the compiler when linking compiled code.
##
## The returned toolchain is a map with the following keys:
## * `paths` - The provided `paths` value
## * `library-paths` - The provided `library-paths` value
## * `target-triple` - The provided `target-triple` value
## * `override` - The provided `override` value
## * `tools` - The indexable collection of tools (e.g. `tools:c++`)
## * `tool-exec-env` - Environment variables needed to exec tools (derived from `paths` and
## `library-paths`).
## * `exec` - A function to exec a tool with the environment set to `tool-exec-env`.
## * `compile-flags` - The compile flags to use with the C++ compiler
## * `c-compile-flags` - The compile flags to use with the C compiler
## * `link-flags` - The link flags to use when linking
## * `target` - A map containing the following target-specific keys:
##   * `architecture` - The toolchain target architecture (`arm`, `aarch64`, `i386`, `x86_64`,
##   `unknown`)
##   * `os` - The toolchain target operating system (`windows`, `linux`, `ios-simulator`, `ios`,
##   `macos`, `unknown`)
##   * `compiler` - The type of the toolchain compiler (`clang`, `gcc`, `msvc`, `unknown`)
##   * `c++lib` - The type of the toolchain's C++ library (`libstdc++`, `libc++`, `msvc`, `unknown`)
##   * `c++abi` - The target ABI of the toolchain (`c++11`, `c++03`)
##   * `lib-path-env` - A function that returns the env to set to add a Path to the library search
##   path.
##   * `preload-libraries` - A function that returns the env to set to add a list of library Paths
##   to the preloaded libraries.
##   * `static-library-name` - A function that returns the filesystem name for a particular static
##   library name.
##   * `dynamic-library-name` - A function that returns the filesystem name for a particular dynamic
##   library name.
##   * `exe-name` - A function that returns the filesystem name for a particular executable name.
toolchain = fn {
    paths = default (Array:Of :Path |> :paths) as !(split-paths <| env:get PATH)
    library-paths = default (Array:Of :Path |> :library-paths) as !(split-paths <| env:get :system-libpath-env)
    target-triple
    override = default (Map:Of :String std:Any |> :override) as {}

    compile-flags = default :compile-flags as []
    c-compile-flags = default :c-compile-flags as []
    link-flags = default :link-flags as []
} -> {
    search = fn (String :tool) -> {
        prefixed = Iter:map (fn :path -> Path:join :path "^(target-triple)-^tool") :paths
        plain = Iter:map (fn :path -> Path:join :path :tool) :paths

        # Prefer prefixed tools
        [:tool] = Iter:flatten [
            Iter:filter fs:exists <| if :target-triple :prefixed else []
            Iter:filter fs:exists :plain
            [:unset]
        ] | Iter:take 1 | Array:from
        :tool
    }
    
    ## Access tools in the toolchain by name.
    ##
    ## Tools are found in the following order:
    ## * If a path is specified in `override::tool`, return it.
    ## * If a string is specified in `override::tool`, use it as the search name in the following procedure.
    ## * Search the provided paths for a tool with the name `"{:target-triple}-{:tool}"`.
    ## * Search the provided paths for a tool with the name `:tool`.
    ## * Return `Unset` if no tool is found.
    ##
    ## Arguments: (String :tool)
    tools = index (String :tool) -> {
        result = cache <| match override::tool [
            Unset _ -> search :tool
            String :name -> search :name
            Path :p -> :p
        ]
        cache ^no-persist <| if :result {
            log:info "Found tool `^tool` at `^result`"
        } else {
            override = match override::tool [String :name -> " (overriden as `^name`)", _ -> ""]
            log:warn "Could not find tool `^tool`^override"
        }
        :result
    }

    tc-env = (Map:from <| Iter:map (fn (std:MapEntry:@ :k :ps) -> std:MapEntry:@ :k (join-paths :ps)) <|
        std:merge { PATH = :paths } { :(!String :system-libpath-env) = :library-paths }
        )

    exec-tool = fn :name ^:args -> exec (env = :tc-env) tools::name ^:args

    detect = fn :filename -> {
        result = std:by-content <| cache {
            file = Path:join :script-dir detection :filename
            exec-result = exec-tool c++ ^:compile-flags -xc++-header -imacros cassert -E -P :file
            exec-result:complete
            String:format "\"{}\"" :result = String:trim <| String:from exec-result:stdout
            :result
        }
        log:debug "detection file `^filename` yielded `^result`"
        :result
    }

    {
        paths
        library-paths
        target-triple
        override
        tools
        tool-exec-env = :tc-env
        exec = :exec-tool

        compile-flags
        c-compile-flags
        link-flags
        target = {
            architecture = detect arch.h
            os = detect os.h
            compiler = detect compiler.h
            c++lib = detect cpplib.h

            c++abi = match :c++lib [
                libstdc++ -> detect gnu_abi.h
                _         -> c++11
            ]

            ## Get the environment variables that should be set to add a path to the library lookup path.
            lib-path-env = fn :path -> { :(!String <| os-libpath-env :os) = :path }

            ## Get the environment variables that should be set to preload an array of libraries.
            ##
            ## Arguments: `(Array:Of :Path |> :libs)`
            preload-libraries = match :os [
                macos -> fn :libs -> { DYLD_INSERT_LIBRARIES = String:join ":" <| Iter:map String:from :libs }
                ios -> fn :libs -> { DYLD_INSERT_LIBRARIES = String:join ":" <| Iter:map String:from :libs }
                linux -> fn :libs -> { LD_PRELOAD = String:join ":" <| Iter:map String:from :libs }
                _ -> fn _ -> {}
            ]

            ## Get the filename for a static library with the given name.
            static-library-name = match :os [
                windows -> fn :name -> "^name.lib"
                _       -> fn :name -> "lib^name.a"
            ]

            ## Get the filename for a dynamic library with the given name.
            dynamic-library-name = match :os [
                windows -> fn :name -> "^name.dll"
                linux   -> fn :name -> "lib^name.so"
                std:bind:or macos ios -> fn :name -> "lib^name.dylib"
                _       -> fn :name -> :name
            ]

            ## Get the filename for an executable with the given name.
            exe-name = match :os [
                windows -> fn :name -> "^name.exe"
                _       -> fn :name -> :name
            ]
        }
    }
}

env-toolchain = {
    ## Parse space-separated flags from an environment variable, if set.
    parse-env-flags = fn :var -> {
        strs = String:split " " (env-or :var "")
        Array:from <| Iter:filter (fn :v -> match :v ["" -> Bool:false, _ -> Bool:true]) :strs
    }

    ## Find binary from environment variable, if set.
    find-env-bin = fn :var -> match (env:get :var) [
        :unset -> :unset
        :value -> match (env:path-search :value) [
            Unset _ -> Path:from :value
            Path :p -> :p
        ]
    ]

    env-bin = {
        cc = CC
        c++ = CXX
        ar = AR
    }

    env-flags = {
        compile-flags = CXXFLAGS
        c-compile-flags = CFLAGS
        link-flags = LDFLAGS
    }

    map-values = fn :f :m -> Map:from <| Iter:map (fn :e -> std:MapEntry:@ e:key (!std:eval <| f e:value)) :m

    ##std:doc:value
    ## A toolchain based on the environment.
    ## 
    ## This toolchain is derived from the following environment variables:
    ## ^(String:join "\n" <| Iter:map (fn :e -> "* `^(e:value)`") <| Iter:flatten [:env-bin,:env-flags])
    ##
    ## If any of these variables are not set, the default value (per `toolchain`) is used instead.
    toolchain {
        override = map-values :find-env-bin :env-bin
        ^map-values :parse-env-flags :env-flags
    }
}

## Handles caching of the given path.
##
## Returns `[:path, :getter]`, where:
## * `path` is the same file path as the input, identified based on content if `file-content-cache` is
## true, and otherwise based on `depends`.
## * `getter` is the function to use to retrieve the path when given the means of writing the path.
##   * I.e. you use the returned `path` in some expression that will write to it, and pass that
##   expression to `getter`.
cached-path = fn :cache-policy :path :depends -> {
    match :cache-policy [
        content -> [:path,:cache]
        configuration -> {
            # We want the path to be explicitly cached on the deps.
            out = cache <| !std:variable ^{ depends } :path
            get-value = fn :v -> {
                # Get the file which tracks the last writer
                last-writer-file = cache <| !std:variable (depends = [last-writer, :out]) (Path:new ())
                # Get a synchronization resource for accessing the file
                last-writer-sync = cache ^no-persist <| std:sync:resource [last-writer-sync, :out] 1
                # Create a string which tracks the argument
                String :me = std:identity :v
                # Atomically access the file
                Path :p = std:sync:consume :last-writer-sync {
                    # Read the last writer, if any.
                    String :last-writer = match ^allow-error (fs:read :last-writer-file) [
                        Error _ -> ""
                        :bs -> String:from :bs
                    ]
                    # Shortcut and return `out` if the last writer was this value.
                    # The returned value should have the same identity as `v`
                    match :last-writer [
                        !:me -> :out
                        _ -> {
                            fs:remove :last-writer-file
                            :v
                            fs:write :last-writer-file :me
                            :out
                        }
                    ]
                }
                !std:variable (depends = :v) :p
            }
            [:out,:get-value]
        }
    ]
}

toolchain-compile-flags = fn :toolchain :compiler -> match :compiler [
    cc -> [
        ^toolchain:c-compile-flags
        ^default toolchain:extra-c-compile-flags as []
    ]
    c++ -> [
        ^toolchain:compile-flags
        ^default toolchain:extra-compile-flags as []
    ]
]

## Compile a file with the given flags.
## The project-root argument is used to ensure the file paths in compiled debug sections are user-friendly.
compile = fn :cache-policy :toolchain :project-root :file :compiler :untracked-flags ^:flags -> {
    proj-path = !Path:relative :project-root :file
    out = Path:join (Path:new ()) "^proj-path.o"
    flags = flags:positional

    [:out,:ocache] = cached-path :cache-policy :out [:proj-path, toolchain:tools::compiler, !toolchain-compile-flags :toolchain :compiler, :flags]

    # Always enable PIC by default; this works better for not surprising people with code that
    # can't be linked into a dynamic library (either objects or static libraries). The user can
    # always use `-fno-PIC` to undo this.
    args = Array:from <| Iter:flatten [[toolchain:tools::compiler,-fPIC,-c,-o,:out], toolchain-compile-flags :toolchain :compiler, !std:variable :untracked-flags, :flags, [:file]]

    {
        object = ocache {
            fs:create-dir <| Path:parent :out
            run "compiling ^file" <| exec (env = toolchain:tool-exec-env) ^:args
            :out
        }
        compile-command = {
            arguments = Array:from <| Iter:map String:from :args
            file = String:from :file
            output = String:from :out
            directory = "/"
        }
    }
}

## Convert an array of header directories to include arguments for the compiler.
to-includes = fn :header-dirs -> {
    :header-dirs | Iter:map (fn :d -> [-I,:d]) | Iter:flatten | Array:from
}

##std:doc:type
## The Module type.
##
## Internally, the type holds a single value, often a dynamic one that yields a Map.
Module = std:type:new (bind = _ -> :v -> std:Error:@ (source=:v) "cannot directly access Module") "ergo-cpp:Module" <| match:value [
    fn :v -> cache ^no-persist :v
    pat :out -> :v -> bind :out :v
]

##std:doc:type
## Module linking type.
##
## This type is used in the `link` field resulting from evaluating modules.
##
## It has the following String constructors:
## `Object`, `StaticLib`, `DynamicLib`, `Flag`
ModuleLink = std:type:enum "ergo-cpp:ModuleLink" {
    # These are all `Any` because we don't want to force evaluation of inner values (otherwise
    # evaluation may end up serialized).
    Object = std:Any
    StaticLib = std:Any
    DynamicLib = std:Any
    Flag = std:Any
}

##std:doc:module
## Functions to get values from a module `link` field.
module-link = {
    ## Get the inner ModuleLink values with the given types.
    ##
    ## Arguments: `(Array:Of :String |> :types) (Into<Iter> :link)`
    ##
    ## Returns an Array.
    types = fn (Array:Of :String |> :types) :link -> Array:from <| Iter:map (fn {val} -> :val) <| Iter:filter (fn :a -> :a) <| Iter:map (fn (ModuleLink :x) -> match :x [
        ^Array:from <| Iter:map (fn :type -> ModuleLink::type :s -> {val = :s}) :types
        _ -> std:Bool:false
    ]) :link

    ## Get the ModuleLink values with the given types.
    ##
    ## Arguments: `(Array:Of :String |> :types) (Into<Iter> :link)`
    ##
    ## This differ from `types` as it doesn't unwrap the inner values.
    ##
    ## Returns an Array of ModuleLink.
    subset = fn (Array:Of :String |> :types) :link -> Array:from <| Iter:map (fn {val} -> :val) <| Iter:filter (fn :a -> :a) <| Iter:map (fn (ModuleLink :x) -> match :x [
        ^Array:from <| Iter:map (fn :type -> std:bind:and :v (ModuleLink::type _) -> {val = :v}) :types
        _ -> std:Bool:false
    ]) :link

    ## Map a function over the inner ModuleLink values.
    ##
    ## Arguments: `(Function :f) (Into<Iter> :link)`
    ##
    ## Returns an Array of ModuleLink.
    map = fn (std:Function :f) :link -> Array:from <| Iter:map (fn (ModuleLink :x) -> match :x [
        ^Array:from <| Iter:map (fn :type -> ModuleLink::type :s -> ModuleLink::type <| f :s) [Object,StaticLib,DynamicLib,Flag]
        _ -> std:Bool:false
    ]) :link

    ## Get the inner ModuleLink values.
    ##
    ## Arguments: `(Into<Iter> :link)`
    ##
    ## Returns an Array.
    unwrap = std:Function:partial :types [Object,StaticLib,DynamicLib,Flag]
}

## Return a file path that depends on all include dependencies, given a map of header paths to dependencies
## that will be used for includes that do not resolve to a file.
set-file-deps = fn ^{ banned-headers, file-type } :toolchain (Path :file) :compiler :untracked-compile-flags :compile-flags (Map :known-headers) -> {
    deps = cache {
        file-type-flag = if :file-type "-x^file-type"
        result = (toolchain:exec :compiler
                ^(!toolchain-compile-flags :toolchain :compiler) -DERGO_CPP_HEADER_DEPENDS -MM -MG ^(!std:variable :untracked-compile-flags)
                ^:compile-flags :file-type-flag (!fs:track :file))
        deps = {
            String:format "{}: {}" _ :parts = result:stdout | String:from | String:trim
            (:parts
            # Split on continuation newlines from make syntax
            | String:split "\\\n"
            # Split on spaces (XXX this will break on filenames with spaces)
            | Iter:map (fn :p -> String:split " " :p) | Iter:flatten
            # Remove empty parts
            | Iter:filter (fn :v -> match :v ["" -> Bool:false,_ -> Bool:true]))
        }
        failure = {
            log:warn "Couldn't determine dependencies for ^file"
            match :file-type [
                c++-header -> log:warn result:stderr
                _ -> Error:@ result:stderr
            ]
            Iter:from []
        }
        if result:exit-status :deps else :failure
    }
    # split files based on whether they exist or not
    {exist,to-check} = cache {
        Iter:zip :exist :to-check = Iter:map (fn :dep -> if (fs:exists <| Path:from :dep) [:dep,:unset] else [:unset,:dep]) :deps
    }
    Array :exist-depends = Array:from <| Iter:map fs:track :exist
    banned-check = if :banned-headers (fn :x -> if banned-headers::x { std:Error:@ (source=:file) "private include (^x) used in public header ^file" }) else (fn _ -> ())
    String :id = std:by-content <| cache {
        Array :known-depends = Array:from <| Iter:no-errors <| Iter:map (fn :dep -> !std:eval <| match known-headers::dep [ std:Unset _ -> banned-check :dep, :v -> :v ]) :to-check
        std:identity [:exist-depends, :known-depends, !fs:track :file, toolchain:tools::compiler, !toolchain-compile-flags :toolchain :compiler, :compile-flags]
    }
    std:variable (depends=:id) :file
}

glob-src = fn :dir :pattern -> fs:glob <| Path:join :dir :pattern

## Get `files` in the current script directory.
##
## Arguments: `()`
##
## The return value is suitable to be passed directly as the `files` key in the `module`
## configuration.
all-files = fn () (dir = std:Path:or-source ^parent :dir) -> glob-src :dir *.cpp

## Get `headers` from a heirarchical description.
##
## Arguments: `:descr`
##
## `decr` may be one of:
## * `all` to get all headers in the current script directory,
## * an `Array` of files, or
## * a `Map` where keys are the `#include` path components and values are
##   recursively evaluated as `descr`.
##
## The return value is suitable to be passed directly as the `headers` key in the `module`
## configuration.
header-paths = {
    inner = std:Function:recursive <| fn :self :descr -> {
        match :descr [
            all -> Iter:map (fn :a -> std:MapEntry:@ (!Path:from <| Path:name :a) :a) <| glob-src (default (std:source:dir :descr) as std:env:current-dir) *.h
            Array :files -> Iter:map (fn :a -> std:MapEntry:@ (!Path:from <| Path:name <| Path:from :a) (Path:from :a)) :files
            Map :dirs -> {
                Iter:flatten <| Iter:map (fn (std:MapEntry:@ :key :val) -> {
                    paths = self :self :val
                    key = Path:join ^(String:split / :key)
                    Iter:map (fn (std:MapEntry:@ :to :from) -> std:MapEntry:@ (!Path:join :key :to) :from) :paths
                }) :dirs
            }
        ]
    }
    fn :descr -> Map:from <| inner :descr
}

context-key = "ergo-cpp:context"

eval-when = fn _ :val -> !std:eval :val

##std:doc:value
## The ergo-cpp context.
##
## This is a dynamic binding evaluating to a `Map` containing:
## * `Path :project-root` - The root directory of the project.
## * `:toolchain` - The toolchain to use.
## * `Map :options` - Additional options affecting compilation and linking.
## * `Map :extra` - User-defined values.
context = std:dynamic:get :context-key

context-fn = pat :ctx ^:rest -> :v -> {
    bind :ctx <| !eval-when :v :context
    bind :rest :v
    ()
}

## Convert a path to an include string.
path-to-include = fn :p -> String:join "/" <| match (Path:split :p) [
    # Remove a leading `.`, if any
    [.,^:rest] -> :rest
    :rest -> :rest
]

modules = Array:Of :Module
match-uses = pat :tgt -> match:value [
    { private = default (modules :private) as []
      public = default (modules :public) as []
      export = default (modules :export) as []
    } -> {
        bind :tgt { private, public, export }
    }

    default (modules :uses) as [] -> {
        bind :tgt { private = :uses, public = [], export = [] }
    }
]

vis = {
    map = fn (std:Function :f) :v -> {
        private = f v:private
        public = f v:public
        export = f v:export
    }
    internal = fn :v -> Iter:flatten [v:public, v:private]
    external = fn :v -> Iter:flatten [v:public, v:export]
    all = fn :v -> Iter:flatten [v:public, v:private, v:export]
    eval = fn :v -> {
        internal = internal :v
        external = external :v
    }
    map* = fn (std:Function :f) :v -> {
        internal = f v:internal
        external = f v:external
    }
}

## Evaluate uses.
##
## Arguments: `:uses`
##
## `uses` should be the output of a `match-uses` binding, specifically a map of
## private/public/export uses modules.
##
## Returns a map with:
## * `uses` - all uses outputs
## * `header-dirs` - a map of internal/external header-dirs
## * `header-deps` - a map of internal/external header-deps
eval-uses = fn :uses -> {
    uses = vis:map (std:Function:partial Iter:map (fn (Module:@ :u) -> :u)) :uses
    int-ext = vis:eval :uses
    uses-header-dirs = vis:map* (fn :uses -> <| :uses | Iter:map (fn :m -> m:header-dirs) | Iter:flatten | Iter:unique) :int-ext
    uses-header-deps = vis:map* (fn :uses -> <| :uses | Iter:map (fn :m -> m:header-deps) | Iter:filter (fn :a -> :a) | Iter:flatten | Map:from) :int-ext
    {
        uses = vis:all :uses
        header-dirs = :uses-header-dirs
        header-deps = :uses-header-deps
    }
}

module-result = fn :all-uses { link, runtime, compile-commands, header-dirs, header-deps, ^:rest } -> {
    # Evaluate these arrays because we want the resulting map to depend on the identities of the
    # array contents.
    Array :link = Array:from <| Iter:unique <| Iter:flatten [
        Iter:map (fn :m -> m:link) :all-uses | Iter:flatten
        :link
    ]
    Array :runtime = Array:from <| Iter:unique <| Iter:flatten [
        Iter:map (fn :m -> m:runtime) :all-uses | Iter:flatten
        Iter:map (fn :m -> m:runtime-if-used) :all-uses | Iter:filter (fn :a -> :a) | Iter:flatten
        :runtime
    ]
    Array :compile-commands = Array:from <| Iter:unique <| Iter:flatten [
        :all-uses | Iter:map (fn :u -> u:compile-commands) | Iter:filter (fn :a -> :a) | Iter:flatten
        :compile-commands
    ]

    { link, header-dirs = header-dirs:external, header-deps = header-deps:external, runtime, compile-commands, ^:rest }
}

## Create a module with the given configuration.
##
## Arguments: `(Map :config)`
## 
## The configuration should be a map with the following optional keys:
## * `files`: an array of the files to compile
## * `headers`: a map with the headers to expose, where the key is the `#include` Path and the value
##   is the header file Path.
## * `uses`: the modules to use with this module, either an array (with private visibility) or a map
##   with the following optional keys:
##   * `public`: an array of modules which will be used when compiling files in this module
##     and will be visible to consumers of this module.
##   * `private`: an array of modules which will be used when compiling files in this module.
##   * `export`: an array of modules which will be visible to consumers of this module.
## * `compile-flags`: additional compilation flags to use when compiling C++ files in this module
## * `c-compile-flags`: additional compilation flags to use when compiling C files in this module
## 
## In both files and headers, if a file is a relative path, it will be relative to the calling
## script directory. To set the relative path explicitly, pass the keyed argument `relative-dir`.
## 
## The returned value will be a Module, where the output will be a map with the following keys:
## * `impl`: an array of compiled object files
## * `header-dirs`: an array of header directories exported by the module (and all directories from used modules)
## * `header-deps`: a map from header paths to the file to which they resolve
##   (where the file value also incorporates all header dependencies when deriving
##   its identity)
## * `runtime`: an array of any additional requirements of the module (inherited from used modules)
## * `compile-commands`: an array of compile commands to build the module and all dependent modules
module = context-fn :ctx (relative-dir = std:Path:or-source ^parent :relative-dir) {
    files = default (Array :files) as []
    headers = default (Map :headers) as {}
    uses = match-uses :uses
    compile-flags = default (Array :compile-flags) as []
    c-compile-flags = default (Array :c-compile-flags) as []
} -> Module:@ {
    files = !Iter:map (fn :f -> !fs:track <| Path:join :relative-dir :f) :files
    headers-spec = :headers
    headers = !Iter:map (fn (std:MapEntry:@ :to :from) -> std:MapEntry:@ :to (!fs:track <| Path:join :relative-dir :from)) :headers
    evaled = eval-uses :uses

    header-dir = {
        [:dir,:hdcache] = cached-path ctx:options:cache-policy (Path:new ()) [:headers-spec, :relative-dir]
        hdcache {
            fs:remove :dir # Clear any existing directory
            fs:create-dir :dir # Ensure path exists if empty
            Array:from <| Iter:map (fn (std:MapEntry:@ :to :from) -> fs:copy (shallow=symbolic) :from (Path:join :dir :to)) :headers
            :dir
        }
    }

    header-dirs = vis:map* (fn :header-dirs -> Array:from <| Iter:flatten [[:header-dir], :header-dirs]) evaled:header-dirs

    includes = to-includes header-dirs:internal

    # headers should have file-deps based on the external `uses` header-deps to ensure no headers depends on internal uses 
    # ban internal header-deps so that if they are used, an error will occur about exposing a private module
    Array :mod-header-deps = Array:from <| Iter:no-errors <| Iter:map (fn (std:MapEntry:@ :to :from) -> !{
        v = (!std:eval <| set-file-deps (banned-headers = evaled:header-deps:internal) (file-type = c++-header)
            ctx:toolchain :from c++ [-I,:header-dir] :compile-flags evaled:header-deps:external)
        :v # if `v` is an error, fail fast
        std:MapEntry:@ (!String <| path-to-include :to) :v
    }) :headers
    header-deps = vis:map* (fn :uses-header-deps -> Map:from <| Iter:flatten [:uses-header-deps,:mod-header-deps]) evaled:header-deps

    compiles = !Iter:map (fn :f -> {
        {compiler, flags} = match (String:split . <| Path:name :f):-1 [
            std:bind:or c C -> { compiler = cc, flags = :c-compile-flags }
            _ -> { compiler = c++, flags = :compile-flags }
        ]
        f = !std:eval <| set-file-deps ctx:toolchain :f :compiler [] :flags header-deps:internal
        compile ctx:options:cache-policy ctx:toolchain ctx:project-root :f :compiler :includes ^:flags
    }) :files
    objects = Iter:map (fn :c -> ModuleLink:Object c:object) :compiles
    compile-commands = Iter:map (fn :c -> c:compile-command) :compiles

    module-result evaled:uses { link = :objects, runtime = [], compile-commands, header-dirs, header-deps }
}

## Create a module that is already compiled.
##
## Arguments: `(Map :config)`
## 
## The configuration should be a map with the following optional keys:
## * `(Array:Of :ModuleLink) :link` - object files/libraries to link
## * `(Array:Of :Path) :include-dirs` - include directories
## * `(Array:Of :Path) :runtime` - libraries (typically dynamic) needed at runtime
## * `(Map :header-deps)` - a map from include path to header file path, which helps in resolving header dependencies
## * `Array :compile-commands` - an array of compile commands that are used to produce the module,
##   where items are maps with:
##   * `Array :arguments` - the arguments in the compile command (including executable)
##   * `Path :file` - the input file of the command (absolute path)
##   * `Path :out` - the output file of the command (absolute path)
## * `uses`: the modules to use with this module, either an array (with private visibility) or a map
##   with the following optional keys:
##   * `public`: an array of modules which will be used when compiling files in this module
##     and will be visible to consumers of this module.
##   * `private`: an array of modules which will be used when compiling files in this module.
##   * `export`: an array of modules which will be visible to consumers of this module.
##
##  Any additional keys in the config map will be copied in the module result.
## 
## The returned value will be a Module, where the output will be a map with the following keys:
## * `impl`: an array of compiled object files
## * `header-dirs`: an array of header directories exported by the module (and all directories from used modules)
## * `header-deps`: a map from header paths to the file to which they resolve
##   (where the file value also incorporates all header dependencies when deriving
##   its identity)
## * `runtime`: an array of any additional requirements of the module (inherited from used modules)
## * `compile-commands`: an array of compile commands to build the module and all dependent modules
## * additional keys from the config map
compiled-module = fn {
    link = default (Array :link) as []
    include-dirs = default (Array:Of :Path |> :includes) as []
    runtime = default (Array:Of :Path |> :runtime) as []
    header-deps = default (Map :header-deps) as {}
    compile-commands = default (Array :compile-commands) as []
    uses = match-uses :uses
    ^:rest
} -> Module:@ {
    evaled = eval-uses :uses
    header-dirs = vis:map* (fn :header-dirs -> Array:from <| Iter:flatten [:includes, :header-dirs]) evaled:header-dirs
    header-deps = vis:map* (fn :uses-header-deps -> Map:from <| Iter:flatten [:uses-header-deps, :header-deps]) evaled:header-deps

    module-result evaled:uses { link, runtime, compile-commands, header-dirs, header-deps, ^:rest }
}

eval-flags = context-fn :ctx {compile-flags, c-compile-flags, link-flags} :f -> {
    newctx = {
        ^:ctx
        Map :toolchain = {
            ^ctx:toolchain
            extra-compile-flags = !std:by-content :compile-flags
            extra-c-compile-flags = !std:by-content :c-compile-flags
        }
    }
    link-flags = !std:by-content :link-flags
    std:dynamic:eval { ::context-key = :newctx } <| f :link-flags
}

## Flag a string as being an exact name, so that no target-specific rules are applied.
exact-name = {
    key = "ergo-cpp:exact-name"
    match:value [
        fn :name -> std:meta:set :key () :name
        pat :out -> :name -> {
            if (std:meta:get :key :name) (bind :out :name) else (std:Error:@ (source=:name) "not an exact-name")
            ()
        }
    ]
}

## Link a module.
link = context-fn :ctx ^{abi-version = default :abi-version as ()} (Path :source) (String :name) (Module:@ :mod) :additional-flags :type :include-headers -> Module:@ {
    os = ctx:toolchain:target:os
    start-group-flag = match :os [
        linux -> ["-Wl,--start-group"]
        _     -> []
    ]

    end-group-flag = match :os [
        linux -> ["-Wl,--end-group"]
        _     -> []

    ]

    # Handle abi version specifics
    {abi-flags,abiname,links,^_} = match :abi-version [
        String :s -> {
            max-version = String:split . :s |>:0
            String :compat-version = match :os [
                macos -> {
                    String:format "{}.dylib" :prefix = :name
                    "^prefix.^max-version.dylib"
                }
                _ -> "^name.^max-version"
            ]
            abi-flags = match :os [
                macos -> {
                    install-name = "-Wl,-install_name,^compat-version"
                    match :max-version [
                        0 -> [:install-name]
                        _ -> [
                            :install-name,
                            "-Wl,-compatibility_version,^max-version",
                            "-Wl,-current_version,^abi-version"
                        ]
                    ]
                }
                # XXX For now assume windows is using something gnuish
                _ -> ["-Wl,-soname,^compat-version"]
            ]
            String :abiname = match :os [
                macos -> {
                    String:format "{}.dylib" :prefix = :name
                    "^prefix.^s.dylib"
                }
                _ -> "^name.^s"
            ]
            links = {
                ::name = :compat-version
                ::compat-version = !match :abiname [(!:compat-version) -> :unset, std:Function:pass]
            }
        }
        _ -> {
            abi-flags = []
            abiname = :name
            links = {}
        }
    ]

    call-site = Path:relative ctx:project-root :source

    subdir = Path:join (Path:new ()) :call-site
    file = Path:join :subdir :abiname

    [:file,:fcache] = cached-path ctx:options:cache-policy :file [:call-site, :abiname, ctx:toolchain:tools:c++, ctx:toolchain:link-flags, :additional-flags]

    file = fcache {
        fs:create-dir <| Path:parent :file
        (run "linking ^type ^name" <| ctx:toolchain:exec c++
            ^ctx:toolchain:link-flags ^:additional-flags ^:abi-flags -o :file ^:start-group-flag ^(module-link:unwrap mod:link) ^:end-group-flag)
        # Make symlinks
        Iter:map (fn (std:MapEntry:@ :to :from) -> {
            path = Path:join (Path:parent :file) :to
            if (fs:exists :path) () else (exec ln -sf :from :path |>:complete)
        }) :links
        :file
    }

    links = Array:from <| Iter:map (fn (std:MapEntry:@ :to _) -> Path:join (Path:parent :file) :to) :links

    {
        file
        link = [ModuleLink:DynamicLib :file,^Array:from <| Iter:map ModuleLink:DynamicLib mod:runtime]
        runtime = mod:runtime
        runtime-if-used = [:file,^:links]
        ^!if :include-headers { std:import {header-deps,header-dirs} = :mod } else {}
        compile-commands = mod:compile-commands
    }
}

rename = context-fn :ctx :f :name -> match :name [
    exact-name :name -> :name
    :name -> ctx:toolchain:target::f :name
]

## Create an executable module from a module.
##
## Arguments: `(Map :config)`
##
## The `config` includes:
## * `String :name` - the name of the executable
## * `Module :mod` - the module to make into an executable
## * `optional (Array :compile-flags)` - additional C++ compile flags to use
## * `optional (Array :c-compile-flags)` - additional C compile flags to use
## * `optional (Array :link-flags)` - additional link flags to use
exe = fn (source = std:Path:or-source :source) {
    name = String :name
    module
    compile-flags = default (Array :compile-flags) as []
    c-compile-flags = default (Array :c-compile-flags) as []
    link-flags = default (Array :link-flags) as []
} -> {
    eval-flags {compile-flags,c-compile-flags,link-flags} <| fn :extra-link-flags -> {
        link :source (rename exe-name :name) :module :extra-link-flags executable Bool:false
    }
}

## Create a dynamic library module from a module.
##
## Arguments: `(Map :config)`
##
## The `config` includes:
## * `String :name` - the name of the library
## * `Module :mod` - the module to make into a library
## * `optional (Array :compile-flags)` - additional C++ compile flags to use
## * `optional (Array :c-compile-flags)` - additional C compile flags to use
## * `optional (Array :link-flags)` - additional link flags to use
## * `optional (String :abi-version)` - the abi version of the dynamic library
##   This is used to determine file names and set binary properties. It must be a string of the form
##   `X[.Y[.Z]]`, where `X`, `Y`, and `Z` are non-negative integers.
dynamic-library = fn (source = std:Path:or-source :source) {
    name = String :name
    module
    compile-flags = default (Array :compile-flags) as []
    c-compile-flags = default (Array :c-compile-flags) as []
    link-flags = default (Array :link-flags) as []
    abi-version = std:optional (String :abi-version)
} -> {
    eval-flags {compile-flags,c-compile-flags,link-flags} <| fn :extra-link-flags -> {
        link ^{abi-version} :source (rename dynamic-library-name :name) :module [-shared,^:extra-link-flags] "dynamic library" Bool:true
    }
}

## Create a static library module from a module.
##
## Arguments: `(Map :config)`
##
## The `config` includes:
## * `String :name` - the name of the library
## * `Module :mod` - the module to make into a library
## * `optional (Array :compile-flags)` - additional C++ compile flags to use
## * `optional (Array :c-compile-flags)` - additional C compile flags to use
static-library = context-fn :ctx (source = std:Path:or-source :source) {
    name = String :name
    module
    compile-flags = default (Array :compile-flags) as []
    c-compile-flags = default (Array :c-compile-flags) as []
} -> {
    eval-flags {compile-flags,c-compile-flags} <| fn _ -> {
        Module:@ :mod = :module

        call-site = Path:relative ctx:project-root :source

        String :filename = rename static-library-name :name
        file = Path:join (Path:new ()) :call-site :filename

        [:file,:fcache] = cached-path ctx:options:cache-policy :file [:call-site, :filename, ctx:toolchain:tools:ar]

        file = fcache {
            fs:create-dir <| Path:parent :file
            run "creating static library ^filename" <| ctx:toolchain:exec ar -crs :file ^(module-link:types [Object] mod:link)
            :file
        }

        Module:@ {
            file
            link = [ModuleLink:StaticLib :file, ^module-link:subset [StaticLib,DynamicLib,Flag] mod:link]
            runtime = mod:runtime
            header-dirs = mod:header-dirs
            header-deps = mod:header-deps
            compile-commands = mod:compile-commands
        }
    }
}

Options = pat :opts -> default {
    cache-policy = default :cache-policy as configuration
} as {} -> {
    bind :opts { cache-policy }
}

## Get the output of a Module, using the given configuration.
##
## Arguments: `(Map :config) :module`
##
## The `config` includes:
## * `Path :project-root` (required) - the project root directory, in which all source files to be
##   compiled must exist. This is used so debug info can contain the relative directories of the
##   files.
## * `:toolchain` - the toolchain to use, using the default toolchain if unspecified.
## * `:options` - a map of options affecting behavior, including:
##   * :cache-policy` - may be one of the following:
##      * `configuration` (default) - Outputs are cached based on compilation flags.
##        `exe`/`dynamic-library`/`static-library` outputs _must_ have unique names on a per-script
##        basis. This is because the caching relies on the script path and name when determining the
##        cache target file.
##      * `content` - Outputs are cached based on compilation flags and file content. For example,
##        if you compile, change a file, compile again, and then revert the change, no recompilation
##        will occur because there will already be a compiled output in the cache. This is most
##        useful if switching between branches/commits often.
##
## The configuration will be used to create the ergo-cpp context with the same keys, and this
## context will be used to evaulate `module`. Any additional unrecognized keys will be present as a
## map under the `extra` key in the context.
get-output = fn {
    project-root = Path :project-root
    toolchain = default (Map :tc) as !(toolchain {})
    options = Options :options
    ^:extra
} :module -> {
    Module:@ :v = std:dynamic:eval { ::context-key = { project-root, toolchain = :tc, options, extra } } :module
    :v
}

## Create a compile_commands.json file for all compile commands in the outputs.
##
## Arguments: `^^:outputs`
##
## The outputs should be obtained with `get-output`.
##
## Returns a Path to a compile_commands.json file.
compile-commands = fn ^:outputs -> {
    path = Path:new ()
    file = Path:join :path compile_commands.json
    commands = !Array:from <| Iter:unique <| Iter:flatten <| Iter:map (fn :o -> o:compile-commands) outputs:positional
    fs:create-dir :path
    fs:write :file <| std:json:stringify ^pretty :commands
    :file
}

## Execute an output.
##
## Arguments: `:output ^^:args`
##
## Keyword Arguments:
## * `:runtime-uses` - an array of extra module outputs whose runtime should also be used as part of
##   the executable's runtime
##
## The output should be obtained with `get-output`.
## The output must provide an executable `file` key in the result (like `exe` does).
##
## Returns the result of running `exec`.
exec-output = fn :ret (runtime-uses = default :rt-uses as []) ^:args -> {
    runtime = Iter:flatten [ret:runtime, Iter:map (fn :m -> m:runtime) :rt-uses | Iter:flatten]
    libpath = cache <| Path:with-output <| fn :libpath -> {
        fs:create-dir :libpath # Ensure path exists if empty
        Array:from <| Iter:map (fn :f -> fs:copy :f :libpath) :runtime
    }
    rt-env = match env:os [
        windows -> { PATH = :libpath }
        macos -> { DYLD_LIBRARY_PATH = :libpath }
        # Use preloaded libraries when possible; this avoids issues with filenames not
        # matching linked dependency names (from, e.g., SONAME)
        linux -> { LD_PRELOAD = String:join ":" <| Iter:map String:from :runtime }
    ]
    exec ret:file ^:args (env = { ^default args:keyed:env as {}, ^:rt-env })
}

##std:doc:module
## Types used in the library.
type = {Module, ModuleLink}

##std:doc:module
## The ergo-cpp library.
##
## To compile and link c++ code, this library abstracts groups of files and their header interfaces
## into _modules_. A single module represents compiled code and interfaces to it, but modules do not
## compile the code until necessary. Libraries and executables are also considered modules, and
## modules can depend on other modules. To evaluate a module (thus creating it concretely), use
## `get-output` with the configuration you desire.
{
    type
    context
    module
    compiled-module
    exe
    dynamic-library
    static-library
    get-output
    toolchain
    env-toolchain
    all-files
    header-paths
    exact-name
    compile-commands
    exec-output
    module-link
}
