# The c++ module provides an abstraction over c++ compilation and linking.
# This module assumes binaries that are compatible with gcc flags (typically gcc and clang).

^(ergo std)

# If the first argument is a truth value, return it, otherwise return the second argument.
unless = fn a b -> if :a :a :b

# Return the value of an environment variable, or an alternative value if not set.
env_or = fn name alternative -> value:force <| unless (env:get :name) :alternative

# Run an executable as a task.
run = fn description ^args ^{^kwargs} -> seq [:args,:kwargs] (task :description (exec ^:args ^:kwargs):complete)

filter = fn f arr -> collection:fold (fn acc v -> if (f :v) [^:acc,:v] :acc) [] :arr

parse-env-flags = fn var -> {
    strs = string:split " " (env_or :var "")
    filter (fn v -> match (value:force :v) {
        ="" = ()
        _ = true
    }) :strs
}

# Get default compiler/flags settings.
compiler = env:path-search <| env_or CXX c++
archiver = env:path-search <| env_or AR ar
extra-cflags = parse-env-flags CXXFLAGS
extra-lflags = parse-env-flags LDFLAGS

target-os = (value:force <| value:cache {
    preproc = "#if defined(_WIN32)
\"windows\"
#elif defined(__linux__)
\"linux\"
#elif defined(__APPLE__)
\"mac\"
#else
\"unsupported\"
#endif"
    output = exec ^{ stdin = :preproc, env = { PATH = : } } :compiler ^:extra-cflags -E -P - |>:stdout
    :output | string:from | string:trim | string:split "\""
}):1

value:force <| log debug <| string:format "detected os: {}" :target-os

lib-path-env = fn path -> value:force (match :target-os {
    =mac = { DYLD_LIBRARY_PATH = :path }
    =linux = { LD_LIBRARY_PATH = :path }
    _ = { PATH = :path }
})

static-library-name = fn name -> match :target-os {
    =windows = string:format "{}.lib" :name
    _ = string:format "{}.a" :name
}

dynamic-library-name = fn name -> match :target-os {
    =windows = string:format "{}.dll" :name
    =linux = string:format "lib{}.so" :name
    =mac = string:format "lib{}.dylib" :name
    _ = :name
}

exe-name = fn name -> match :target-os {
    =windows = string:format "{}.exe" :name
    _ = :name
}

# Compile a file with the given flags.
# The project-root argument is used to ensure the file paths in compiled debug sections are user-friendly.
compile = fn project-root file ^flags -> value:cache <| seq ^[
    out = path:join (path:new) (string:format "{}.o" <| path:relative :project-root :file)
    fs:create-dir <| path:parent :out
    run (string:format "compiling {}" :file) ^{ env = { PATH = : } } :compiler ^:extra-cflags -c -o :out ^:flags :file
    :out
]

to-includes = fn header-dirs -> collection:fold (fn l dir -> [^:l,-I,:dir]) [] :header-dirs

with-context = fn f -> {apply-context = :f}

make-header-paths = fn dir descr -> {
    basename = fn f -> { [^_,f] = path:split :f; :f }
    basic = fn descr -> match (value:force :descr) {
        =auto = value:force <| collection:map (fn a -> {from = :a, to = basename :a}) <| fs:glob <| path:join :dir *.h
        [^files] = value:force <| collection:map (fn a -> {from = :a, to = basename :a}) :files
    }
    match :descr {
        {^dirs} = collection:fold (fn ret {key,value} -> [^:ret,^(collection:map (fn {from,to} -> {from,to = path:join :key :to}) <| basic :value)]) [] <| collection:entries :dirs
        o = basic :o
    }
}

#get-include-deps = fn f headers -> value:force <| value:cache {
#    includes = exec sed -n -E "s/[[:space:]]*#include[[:space:]]*(\"|<)([^\">]+)(\"|>)/\\2/p" (fs:track :f) |>:stdout | string:from | string:trim | string:split "\n" | value:cache
#    find-file = fn f -> {
#        f = value:force :f
#        collection:fold (fn a {from, to} -> unless :a (match :f { =(value:force :to) -> :from, _ => () })) () :headers
#    }
#    filter (fn f -> if (file:exists :f) :f <| find-file :f) :includes
#}
#
#file-rely-deps = fn f headers -> seq (get-include-deps :f :headers) (fs:track :f)

# Create a module in the given directory (used for auto parameters) with the given configuration.
#
# The configuration may be "auto", which will get all .cpp and .h files as the
# (non-public) module contents.  Otherwise, it should be a map with the
# following optional keys:
#   files: the files to compile, or "auto"
#   headers: the headers to expose
#   public-headers: the headers to expose publicly, such that any libraries will expose them
#   uses: the modules to use with this module
#
# Headers may be an array of files, "auto", or a map where the keys represent a
# directory, and values are "auto" or an array of files. "auto" will use all
# *.h files in the module path.
#
# The returned module generator function, when passed a compilation context,
# will return a module output map with the following keys:
#   impl: an array of compiled object files
#   header-dirs: an array of header directories exported by the module (and all directories from used modules)
#   runtime: an array of any additional requirements of the module (inherited from used modules)
module = fn dir config -> {
    config = match :config {
        =auto = { files = auto, headers = auto }
        other = :other
    }
    default = fn name -> {
        match config::name {
            =() = []
            other = :other
        }
    }
    files = default files
    headers = default headers
    public-headers = default public-headers
    uses = default uses

    files = match (value:force :files) {
        =auto = value:force <| fs:glob <| path:join :dir *.cpp
        other = :other
    }
    headers = make-header-paths :dir :headers
    public-headers = make-header-paths :dir :public-headers

    with-context (fn context -> {
        uses = collection:map (fn u -> u:apply-context :context) :uses
        header-dirs = collection:fold (fn l use -> [^:l,^use:header-dirs]) [] :uses
        header-dir = value:cache <| seq ^[
            dir = (path:new)
            fs:create-dir :dir
            collection:map (fn {from,to} -> fs:copy (fs:track :from) (path:join :dir :to)) :headers
            collection:map (fn {from,to} -> fs:copy (fs:track :from) (path:join :dir :to)) :public-headers
            :dir
        ]
        header-dirs = [:header-dir,^:header-dirs]
        all-public-headers = collection:fold (fn l use -> [^:l,^use:public-headers]) :public-headers :uses
        includes = to-includes :header-dirs

        # Imbue dependencies into file
        # files = collection:map (fn f -> file-rely-deps :f [^:headers,^:public-headers]) :files

        objects = collection:map (fn f -> compile context:project-root :f ^:includes ^context:cflags) :files
        impl = collection:fold (fn l use -> [^:l,^use:impl]) :objects :uses
        runtime = collection:fold (fn l use -> [^:l,^use:runtime,^(value:force <| unless use:runtime-if-used [])]) [] :uses
        { impl, header-dirs, public-headers = :all-public-headers, runtime }
    })
}

# Link a module.
link = fn ^{^kwargs} name mod additional-flags type -> with-context (fn context -> value:cache <| seq ^[
    out = (path:new)
    fs:create-dir :out
    out = path:join :out :name
    kwcflags = value:force <| unless kwargs:cflags []
    kwlflags = value:force <| unless kwargs:lflags []
    cflags = [^context:cflags,^:kwcflags]
    lflags = [^context:lflags,^:kwlflags]
    mod = mod:apply-context {project-root = context:project-root, cflags, lflags}
    run (string:format "linking {} {}" :type :name) ^{ env = {PATH = :} } :compiler ^:extra-lflags ^:additional-flags ^:lflags -o :out "-Wl,--start-group" ^mod:impl "-Wl,--end-group"
    { file = :out, impl = [:file,^mod:runtime], runtime = mod:runtime, runtime-if-used = [:file], header-dirs = mod:header-dirs }
])

# Link a module into an executable.
exe = fn ^{^kwargs} name mod -> with-context (fn context -> {
    ret = link ^:kwargs (exe-name :name) :mod [] executable |>:apply-context :context
    {
        ^:ret
        exec = fn ^args ^{^kwargs} -> {
            libpath = value:cache <| seq ^[
                libpath = (path:new)
                fs:create-dir :libpath
                collection:map (fn f -> fs:copy :f :libpath) <| value:force :runtime
                :libpath
            ]
            exec ^{ env = {}, ^:kwargs, env = { ^:env, ^(lib-path-env :libpath) } } :file ^:args
        }
    }
})

# Link a module into a dynamic library.
dynamic-library = fn ^{^kwargs} name mod -> link ^{ cflags = [], ^:kwargs, cflags = [^:cflags,-fPIC] } (dynamic-library-name :name) :mod [-shared] "dynamic library"

# Link a module into a static library.
static-library = fn ^{cflags} name mod -> with-context (fn context -> {
    out = (path:new)
    fs:create-dir :out
    filename = static-library-name :name
    out = path:join :out :filename
    cflags = if :cflags [^context:cflags,^:cflags] context:cflags
    mod = mod { ^:context, cflags }
    run (string:format "creating static library {}" :filename) :archiver -crs :out ^mod:impl
    { file = :out, impl = [:file], runtime = mod:runtime, header-dirs = mod:header-dirs }
})

{
    module
    exe
    dynamic-library
    static-library
    apply-context = fn project-root cflags lflags t -> t:apply-context {project-root,cflags,lflags}
    name = {
        static-library = static-library-name
        dynamic-library = dynamic-library-name
        exe = exe-name
    }
    target-os
}
