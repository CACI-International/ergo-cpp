# The c++ module provides an abstraction over c++ compilation and linking.
# This module assumes binaries that are compatible with gcc flags (typically gcc and clang).

^ergo std

log = log sublog c++

script-dir = script:dir:

## If the first argument is a truth value, return it, otherwise return the second argument.
unless = fn :a :b -> if :a :a :b

## If the map contains a key, return it, otherwise return the third argument.
unless-map = fn :m :k :else -> !if (collection:has :m :k) m::k :else

## Return the value of an environment variable, or an alternative value if not set.
env_or = fn :name :alternative -> value:by-content <| unless (env:get :name) :alternative

## Run an executable as a task (counting as one task).
run = fn :description ^:args ^{^:kwargs} -> task ^{task-count = 1} :description (exec ^:args ^:kwargs):complete

## Filter an array based on a predicate.
filter = fn :f :arr -> collection:fold (fn :acc :v -> if (f :v) [^:acc,:v] :acc) [] :arr

## Parse space-separated flags from an environment variable, if set.
parse-env-flags = fn :var -> {
    strs = string:split " " (env_or :var "")
    # collection:filter
    filter (fn :v -> match (value:by-content :v) ("" -> ()) (_ -> true)) :strs
}

## Create a toolchain from the given configuration.
## 
## The single argument should be a map, optionally specifying the following keys:
## * `compiler` - The compiler to use (as a binary name or path)
## * `archiver` - The archiver to use (as a binary name or path)
## * `compile-flags` - Flags to always pass to `compiler` when compiling source code.
## * `link-flags` - Flags to always pass to `compiler` when linking compiled code.
toolchain = fn :config -> {
    compiler = env:path-search <| unless-map :config compiler c++
    archiver = env:path-search <| unless-map :config archiver ar
    compile-flags = unless-map :config compile-flags []
    link-flags = unless-map :config link-flags []

    detect = fn :filename -> value:cache <| value:by-content {
        file = path:join :script-dir detection :filename
        output = exec ^{ env = { PATH = env:get PATH } } :compiler ^:compile-flags -E -P :file |>:stdout
        output = string:from :output | string:trim | string:split "\"" |>:1
        !log debug <| string:format "detection file `{}` yielded `{}`" :filename :output
        :output
    }

    {
        compiler
        archiver
        compile-flags
        link-flags
        target = {
            architecture = detect arch.h
            os = detect os.h
            compiler = detect compiler.h

            # The below should be doc comments, but ergo beta 8 has a bug where it doesn't parse correctly.
            # The bug has been fixed, and the next release will allow these to be doc comments again.

            # Get the environment variables that should be set to add a path to the library lookup path.
            lib-path-env = match :os ^[
                macos -> fn :path -> value:by-content { DYLD_LIBRARY_PATH = :path }
                ios   -> fn :path -> value:by-content { DYLD_LIBRARY_PATH = :path }
                linux -> fn :path -> value:by-content { LD_LIBRARY_PATH = :path }
                _     -> fn :path -> value:by-content { PATH = :path }
            ]

            # Get the filename for a static library with the given name.
            static-library-name = match :os ^[
                windows -> fn :name -> string:format "{}.lib" :name
                _       -> fn :name -> string:format "{}.a" :name
            ]

            # Get the filename for a dynamic library with the given name.
            dynamic-library-name = match :os ^[
                windows -> fn :name -> string:format "{}.dll" :name
                linux   -> fn :name -> string:format "lib{}.so" :name
                macos   -> fn :name -> string:format "lib{}.dylib" :name
                ios     -> fn :name -> string:format "lib{}.dylib" :name
                _       -> fn :name -> :name
            ]

            # Get the filename for an executable with the given name.
            exe-name = match :os ^[
                windows -> fn :name -> string:format "{}.exe" :name
                _       -> fn :name -> :name
            ]
        }
    }
}

## Get a toolchain based on the environment.
## 
## This toolchain is derived from the environment variables `CXX`, `AR`, `CXXFLAGS`, and `LDFLAGS`. 
## If `CXX` is not set, `c++` is used.
## If `AR` is not set, `ar` is used.
env-toolchain = fn: -> toolchain {
    compiler = env_or CXX c++
    archiver = env_or AR ar
    compile-flags = parse-env-flags CXXFLAGS
    link-flags = parse-env-flags LDFLAGS
}

## Compile a file with the given flags.
## The project-root argument is used to ensure the file paths in compiled debug sections are user-friendly.
compile = fn :toolchain :project-root :file :untracked-flags ^:flags -> value:cache <| seq ^[
    out = path:join (path:new) (string:format "{}.o" <| path:relative :project-root :file)
    fs:create-dir <| path:parent :out
    run (string:format "compiling {}" :file) ^{ env = { PATH = env:get PATH } } toolchain:compiler ^toolchain:compile-flags -c -o :out ^(value:variable :untracked-flags) ^:flags :file
    :out
]

## Convert an array of header directories to include arguments for the compiler.
# collection:precede
to-includes = fn :header-dirs -> collection:fold (fn :l :dir -> [^:l,-I,:dir]) [] :header-dirs

## The Module type.
Module = type:new "ergo-cpp:Module" type:Function

## Create a recursive function. The first argument to the given function will be the function itself.
fix = fn :f -> fn ^:args ^{^:kwargs} -> f :f ^:args ^:kwargs

## Return a file path that depends on all include dependencies, given a map of header paths to dependencies
## that will be used for includes that do not resolve to a file.
set-file-deps = fn :toolchain :file :untracked-compile-flags :compile-flags :known-headers -> {
    deps = string:from (exec (env = { PATH = env:get PATH }) toolchain:compiler ^toolchain:compile-flags -DERGO_CPP_HEADER_DEPENDS -MM -MG ^:untracked-compile-flags ^:compile-flags :file):stdout | string:trim
    # string:regex
    parts = value:dynamic (fn [_,^:parts] -> :parts) |> (string:split ":" :deps)
    parts = collection:fold (fn :arr :p -> [^:arr,^(string:split "\\\n" :p)]) [] :parts
    parts = collection:fold (fn :arr :p -> [^:arr,^(string:split " " :p)]) [] :parts
    parts = collection:fold (fn :arr :p -> match :p ("" -> :arr) (:o -> [^:arr,:o])) [] :parts
    parts = value:cache <| value:variable ^{ depends = [file-deps, fs:track :file, toolchain:compiler, toolchain:compile-flags, :compile-flags] } :parts
    # existing files depend on the result of fs:track, otherwise look in known-headers
    depends = !collection:map (fn :dep -> !if (fs:exists <| path:join :dep) (fs:track :dep) (unless-map :known-headers !:dep ())) :parts
    value:variable ^{ depends } :file
}

## Convert a path to an include string.
path-to-include = fn :p -> {
    [:a,^:rest] = path:split :p
    # string:join
    value:by-content <| collection:fold (fn :s :c -> string:format "{}/{}" :s :c) :a :rest
}

ByContent = pat :tgt -> :v -> {!:tgt = value:by-content :v}

## Returns a map of include paths (as strings) to tracked header files.
make-header-paths = fix (fn :self :dir :descr -> {
    !match :descr ^[
        type:String (ByContent auto) -> value:by-content <| collection:map (fn :a -> {from = :a, to = path:join <| path:name :a}) <| fs:glob <| path:join :dir *.h
        [^:files] -> value:by-content <| collection:map (fn :a -> {from = path:join :dir :a, to = path:join <| path:name <| path:join :a}) :files
        {^:dirs} -> {
            !collection:fold (fn :ret {key,value} -> [^:ret,^{
                paths = self :self :dir :value
                !collection:map (fn {from,to} -> {from,to = path:join :key :to}) :paths
            }]) [] <| collection:entries :dirs
        }
    ]
})

## Remove duplicate values in an array.
# collection:unique
uniq = fn :arr -> {
    !collection:fold (fn :state :a -> !if (collection:has state:0 :a) :state [{^state:0, :a = ()},[^state:1,:a]]) [{},[]] :arr |>:1
}

## Create a module with the given configuration.
## 
## The configuration may be "auto", which will get all .cpp and .h files in the calling script's directory as the
## (non-public) module contents. Otherwise, it should be a map with the following optional keys:
## * `files`: the files to compile, or "auto"
## * `headers`: the headers to expose
## * `uses`: the modules to use with this module
## * `cflags`: additional compilation flags to use when compiling files in this module
## 
## Headers may be an array of files, "auto", or a map where the keys represent a
## directory, and values are "auto" or an array of files. "auto" will use all
## *.h files in the module path.
## 
## In both files and headers, if a file is a relative path, it will be relative to the script directory. When "auto" is used,
## this directory is also used. To set it explicitly, pass the keyword argument `relative-dir`.
## 
## The returned value will be a Module, which when applied to a context will
## return a map with the following keys:
## * `impl`: an array of compiled object files
## * `header-dirs`: an array of header directories exported by the module (and all directories from used modules)
## * `header-deps`: a map from header paths to the file to which they resolve
##   (where the file value also incorporates all header dependencies when deriving
##   its identity)
## * `runtime`: an array of any additional requirements of the module (inherited from used modules)
module = fn ^{^:kwargs} :config -> {
    dir = if (collection:has :kwargs relative-dir) kwargs:relative-dir (script:dir)
    config = match :config ^[
        auto -> { files = auto, headers = auto }
        :other -> :other
    ]

    default = fn :name -> unless-map :config :name []
    files = default files
    headers = default headers
    uses = default uses
    compile-flags = unless-map :config compile-flags (fn :e -> [])

    files = match :files ^[
        type:String (ByContent auto) -> value:by-content <| fs:glob <| path:join :dir *.cpp
        :other -> !collection:map (fn :f -> path:join :dir :f) :other
    ]
    headers = make-header-paths :dir (value:by-content :headers)

    # unpack uses to immediately verify they are modules
    uses = !collection:map (fn (Module :u) -> :u) :uses

    Module (fn :context -> {
        uses = !collection:map (fn :u -> u :context) :uses
        # collection:flatten
        header-dirs = collection:fold (fn :l :use -> [^:l,^use:header-dirs]) [] :uses
        header-dir = value:cache <| seq ^[
            dir = path:new:
            fs:create-dir :dir
            collection:map (fn {from,to} -> fs:copy (fs:track :from) (path:join :dir :to)) :headers
            :dir
        ]
        header-dirs = [:header-dir,^uniq :header-dirs]
        includes = to-includes :header-dirs
        compile-flags = compile-flags context:extra

        # Create maps from header path to dependency
        # collection:filter
        uses-header-deps = !collection:fold (fn :m :use -> !if (collection:has :use header-deps) {^:m,^use:header-deps} :m) {} :uses
        # collection:map, collection:from-entries
        mod-header-deps = !collection:fold (fn :m {from,to} -> {^:m, :(path-to-include :to) = set-file-deps context:toolchain :from [-I,:header-dir] :compile-flags :uses-header-deps}) {} :headers
        header-deps = {^:uses-header-deps,^:mod-header-deps}

        objects = collection:map (fn :f -> compile context:toolchain context:project-root (set-file-deps context:toolchain :f [] :compile-flags :header-deps) :includes ^:compile-flags) :files
        # collection:flatten
        impl = collection:fold (fn :l :use -> [^:l,^use:impl]) :objects :uses
        # collection:flatten
        runtime = collection:fold (fn :l :use -> [^:l,^use:runtime,^(value:by-content <| unless-map :use runtime-if-used [])]) [] :uses
        { impl, header-dirs, header-deps, runtime }
    })
}

propagate-flags = fn ^{^:kwargs} :context -> {
    get-flags = fn :key -> value:by-content (if (collection:has :kwargs :key) (kwargs::key context:extra) [])
    {
        ^:context,
        toolchain = {
            ^context:toolchain
            compile-flags = [^context:toolchain:compile-flags, ^get-flags compile-flags]
            link-flags = [^context:toolchain:link-flags, ^get-flags link-flags]
        }
    }
}

## Link a module.
link = fn :name (Module :mod) :additional-flags :type :include-headers -> {
    Module (fn :context -> {
        out = path:new:
        file = path:join :out :name

        mod = mod :context

        file = value:cache <| seq ^[
            fs:create-dir :out
            run (string:format "linking {} {}" :type :name) (env = { PATH = env:get PATH }) context:toolchain:compiler ^context:toolchain:link-flags ^:additional-flags -o :file "-Wl,--start-group" ^mod:impl "-Wl,--end-group"
            :file
        ]
        ret = { file, impl = [:file,^mod:runtime], runtime = mod:runtime, runtime-if-used = [:file] }
        !if :include-headers { ^:ret, header-deps = mod:header-deps, header-dirs = mod:header-dirs } :ret
    })
}

## Create an executable module from a module.
exe = fn {name,module,^:kwargs} -> {
    Module (fn :context -> {
        context = propagate-flags ^:kwargs :context
        Module :mod = link (context:toolchain:target:exe-name :name) :module [] executable ()
        ret = mod :context
        {
            ^:ret
            exec = fn ^:args ^{^:kwargs} -> {
                libpath = value:cache <| seq ^[
                    libpath = (path:new)
                    fs:create-dir :libpath
                    collection:map (fn :f -> fs:copy :f :libpath) <| value:by-content ret:runtime
                    :libpath
                ]
                exec ^{ env = {}, ^:kwargs, env = { ^:env, ^(context:toolchain:target:lib-path-env :libpath) } } ret:file ^:args
            }
        }
    })
}

## Create a dynamic library module from a module.
dynamic-library = fn {name,module,^:kwargs} -> {
    kwargs = {
        compile-flags = fn _ -> []
        ^:kwargs
        compile-flags = fn :e -> [^compile-flags :e,-fPIC]
    }
    Module (fn :context -> {
        Module :mod = link (context:toolchain:target:dynamic-library-name :name) :module [-shared] "dynamic library" true
        mod <| propagate-flags ^:kwargs :context
    })
}

## Create a static library module from a module.
static-library = fn {name,module=Module :mod,^:kwargs} -> {
    Module (fn :context -> {
        out = path:new:
        fs:create-dir :out
        filename = static-library-name context:toolchain :name
        out = path:join :out :filename
        mod = mod <| propagate-flags ^:kwargs :context
        run (string:format "creating static library {}" :filename) context:toolchain:archiver -crs :out ^mod:impl
        { file = :out, impl = [:file], runtime = mod:runtime, header-dirs = mod:header-dirs, header-deps = mod:header-deps }
    })
}

## Get the output of a module, using the given configuration map.
## 
## If the context contains `toolchain` as key, this will be used as the
## toolchain. Otherwise a default toolchain is used.
## All additional values in the configuration map will be passed (as a map) to
## `compile-flags` and `link-flags` functions, if specified.
get-output = fn {project-root,^:config} (Module :mod) -> {
    toolchain = unless-map :config toolchain <| toolchain {}
    extra = {^:config, toolchain=() }
    mod {project-root, toolchain, extra}
}

{
    type = {Module}
    module
    exe
    dynamic-library
    static-library
    get-output
    toolchain
    env-toolchain
}
