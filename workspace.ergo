# The c++ module provides an abstraction over c++ compilation and linking.
# This module assumes binaries that are compatible with gcc flags (typically gcc and clang).

^std:

log = log sublog c++

script-dir = script:dir:

## Return the value of an environment variable, or an alternative value if not set.
env-or = fn :name :alternative -> default (env:get :name) as :alternative

## Run an executable as a task (counting as one task).
run = fn :description ^:args ^{^:kwargs} -> task ^{task-count = 1} :description (exec ^:args ^:kwargs):complete

## Parse space-separated flags from an environment variable, if set.
parse-env-flags = fn :var -> {
    strs = String:split " " (env-or :var "")
    Array:from <| Iter:filter (fn :v -> !match :v ("" -> Bool:false) (_ -> Bool:true)) :strs
}

# TODO divorce the linking/native/binutils stuff from c/c++, separate c and c++ into separate
# libraries

## Create a toolchain from the given configuration.
##
## Arguments: `(Map :config)`
## 
## The `config` may contain the following optional keys:
## * `compiler` - The compiler to use (as a binary name or path), defaulting to `c++`.
## * `c-compiler` - The C compiler to use (as a binary name or path), defaulting to `cc`.
## * `archiver` - The archiver to use (as a binary name or path), defaulting to `ar`.
## * `object-dump` - The tool to inspect generated object files (as a binary or path), defaulting to
##   `objdump`.
## * `compile-flags` - Flags to always pass to `compiler` when compiling source code.
## * `c-compile-flags` - Flags to always pass to `c-compiler` when compiling C source code.
## * `link-flags` - Flags to always pass to `compiler` when linking compiled code.
toolchain = fn {
    compiler = default :compiler as c++
    c-compiler = default :c-compiler as cc
    archiver = default :archiver as ar
    object-dump = default :object-dump as objdump
    compile-flags = default :compile-flags as []
    c-compile-flags = default :c-compile-flags as []
    link-flags = default :link-flags as []
} -> {
    compiler = env:path-search :compiler
    c-compiler = env:path-search :c-compiler
    archiver = env:path-search :archiver
    object-dump = env:path-search :object-dump

    detect = fn :filename -> {
        result = cache {
            file = Path:join :script-dir detection :filename
            output = exec (env = { PATH = env:get PATH }) :compiler ^:compile-flags -imacros cassert -E -P :file |>:stdout
            String:from :output | String:trim | String:split "\"" |>:1
        }
        !log debug <| String:format "detection file `{}` yielded `{}`" :filename :result
        by-content :result
    }

    {
        compiler
        c-compiler
        archiver
        object-dump
        compile-flags
        c-compile-flags
        link-flags
        target = {
            architecture = detect arch.h
            os = detect os.h
            compiler = detect compiler.h
            c++lib = detect cpplib.h

            c++abi = !match :c++lib ^[
                libstdc++ -> detect gnu_abi.h
                _         -> c++11
            ]

            ## Get the environment variables that should be set to add a path to the library lookup path.
            lib-path-env = !match :os ^[
                macos -> fn :path -> { DYLD_LIBRARY_PATH = :path }
                ios   -> fn :path -> { DYLD_LIBRARY_PATH = :path }
                linux -> fn :path -> { LD_LIBRARY_PATH = :path }
                _     -> fn :path -> { PATH = :path }
            ]

            ## Get the filename for a static library with the given name.
            static-library-name = !match :os ^[
                windows -> fn :name -> String:format "{}.lib" :name
                _       -> fn :name -> String:format "{}.a" :name
            ]

            ## Get the filename for a dynamic library with the given name.
            dynamic-library-name = !match :os ^[
                windows -> fn :name -> String:format "{}.dll" :name
                linux   -> fn :name -> String:format "lib{}.so" :name
                macos   -> fn :name -> String:format "lib{}.dylib" :name
                ios     -> fn :name -> String:format "lib{}.dylib" :name
                _       -> fn :name -> :name
            ]

            ## Get the filename for an executable with the given name.
            exe-name = !match :os ^[
                windows -> fn :name -> String:format "{}.exe" :name
                _       -> fn :name -> :name
            ]
        }
    }
}

## Get a toolchain based on the environment.
##
## Arguments: (none)
## 
## This toolchain is derived from the environment variables `CXX`, `CC`, `AR`, `CXXFLAGS`, `CFLAGS`, `LDFLAGS`, and `OBJDUMP`.
## If `CXX` is not set, `c++` is used.
## If `CC` is not set, `cc` is used.
## If `AR` is not set, `ar` is used.
## If `OBJDUMP` is not set, `objdump` is used.
env-toolchain = fn: -> toolchain {
    compiler = env-or CXX c++
    c-compiler = env-or CC cc
    archiver = env-or AR ar
    object-dump = env-or OBJDUMP objdump
    compile-flags = parse-env-flags CXXFLAGS
    c-compile-flags = parse-env-flags CFLAGS
    link-flags = parse-env-flags LDFLAGS
}

## Compile a file with the given flags.
## The project-root argument is used to ensure the file paths in compiled debug sections are user-friendly.
compile = fn :toolchain :project-root :file :untracked-flags ^:flags -> cache <| seq ^[
    out = Path:join Path:new: (String:format "{}.o" <| Path:relative :project-root :file)
    fs:create-dir <| Path:parent :out
    run (String:format "compiling {}" :file) (env = { PATH = env:get PATH }) toolchain:compiler ^toolchain:compile-flags -c -o :out ^(variable :untracked-flags) ^:flags :file
    :out
]

## Convert an array of header directories to include arguments for the compiler.
to-includes = fn :header-dirs -> {
    :header-dirs | Iter:map (fn :d -> [-I,:d]) | Iter:flatten | Array:from
}

## The Module type.
##
## Internally, the type holds a function which, when applied to a _context_, yields some result.
Module = type:new (bind = _ -> _ -> !error:throw "cannot directly access Module") "ergo-cpp:Module" <| match:value ^[
    fn (Function :f) -> Function:memoize :f
    pat :out -> :f -> { !:out = :f }
]

## Return a file path that depends on all include dependencies, given a map of header paths to dependencies
## that will be used for includes that do not resolve to a file.
set-file-deps = fn :toolchain :file :untracked-compile-flags :compile-flags :known-headers -> {
    deps = String:from (exec (env = { PATH = env:get PATH }) toolchain:compiler ^toolchain:compile-flags -DERGO_CPP_HEADER_DEPENDS -MM -MG ^:untracked-compile-flags ^:compile-flags :file):stdout | String:trim
    # String:regex
    parts = Array <| match (String:split ":" :deps) ([_,^:parts] -> :parts)
    # Split on continuation newlines from make syntax
    parts = Iter:map (fn :p -> String:split "\\\n" :p) :parts | Iter:flatten
    # Split on spaces (XXX this will break on filenames with spaces)
    parts = Iter:map (fn :p -> String:split " " :p) :parts | Iter:flatten
    # Remove empty parts
    parts = Iter:filter (fn :v -> !match :v ("" -> Bool:false) (_ -> Bool:true)) :parts
    # Cache based on the file, compiler, and compile flags
    parts = cache <| variable (depends = [file-deps, fs:track :file, toolchain:compiler, toolchain:compile-flags, :compile-flags]) :parts
    # existing files depend on the result of fs:track, otherwise look in known-headers
    depends = !Iter:map (fn :dep -> !if (fs:exists <| Path:join :dep) (fs:track :dep) (default known-headers:(!:dep) as ())) :parts
    variable ^{ depends } :file
}


ByContent = pat :tgt -> :v -> {!:tgt = by-content :v}

## Get `files` in the current script directory.
##
## The return value is suitable to be passed directly as the `files` key in the `module`
## configuration.
all-files = fn: -> fs:glob *.cpp

## Get `headers` from a heirarchical description.
##
## Arguments: `:descr`
##
## `decr` may be one of:
## * `all` to get all headers in the current script directory,
## * an `Array` of files, or
## * a `Map` where keys are the `#include` path components and values are
##   recursively evaluated as `descr`.
##
## The return value is suitable to be passed directly as the `headers` key in the `module`
## configuration.
header-paths = {
    inner = Function:recursive <| fn :self :descr -> {
        !match :descr ^[
            String (ByContent all) -> Iter:map (fn :a -> MapEntry: (by-content (Path:join (Path:name :a))) :a) <| fs:glob *.h
            [^:files] -> Iter:map (fn :a -> MapEntry: (by-content (Path:join (Path:name (Path:join :a)))) (Path:join :dir :a)) :files
            {^:dirs} -> {
                Iter:flatten <| Iter:map (fn (MapEntry: :key :val) -> {
                    paths = self :self :val
                    key = Path:join ^(String:split / :key)
                    Iter:map (fn (MapEntry: :to :from) -> MapEntry: (by-content <| Path:join :key :to) :from) :paths
                }) :dirs
            }
        ]
    }
    fn :descr -> Map:from <| inner :descr
}

## Convert a path to an include string.
path-to-include = fn :p -> by-content <| String:join "/" <| Path:split :p

## Create a module with the given configuration.
##
## Arguments: `(Map :config)`
## 
## The configuration should be a map with the following optional keys:
## * `files`: an array of the files to compile
## * `headers`: a map with the headers to expose, where the key is the `#include` Path and the value
##   is the header file Path.
## * `uses`: the modules to use with this module
## * `compile-flags`: additional compilation flags to use when compiling files in this module
##   This should be a function which is passed the extra context and returns an array of flags.
## 
## In both files and headers, if a file is a relative path, it will be relative to the calling
## script directory. To set the relative path explicitly, pass the keyword argument `relative-dir`.
## 
## The returned value will be a Module, where the output will be a map with the following keys:
## * `impl`: an array of compiled object files
## * `header-dirs`: an array of header directories exported by the module (and all directories from used modules)
## * `header-deps`: a map from header paths to the file to which they resolve
##   (where the file value also incorporates all header dependencies when deriving
##   its identity)
## * `runtime`: an array of any additional requirements of the module (inherited from used modules)
module = fn ^{ relative-dir } {
    files = default (Array :files) as []
    headers = default (Map :headers) as {}
    uses = default (Array:Of :Module |> :uses) as []
    compile-flags = default (Function :compile-flags) as (fn _ -> [])
} -> {
    dir = default :relative-dir as script:dir:

    files = Iter:map (fn :f -> Path:join :dir :f) :files
    headers = Iter:map (fn (MapEntry: :to :from) -> MapEntry: :to (Path:join :dir :from)) :headers

    Module: <| fn :context -> {
        uses = Iter:map-all (fn (Module: :u) -> u :context) :uses
        header-dirs = :uses | Iter:map (fn :m -> m:header-dirs) | Iter:flatten | Iter:unique
        header-dir = cache <| Path:with-output <| fn :dir -> seq ^[
            fs:create-dir :dir # Ensure path exists if empty
            # Force the array so the inner values are the results of `fs:copy`, which will include
            # the `fs:track` identities (so if a header changes, the header-dir is rebuilt).
            !Array:from <| Iter:map-all (fn (MapEntry: :to :from) -> fs:copy (fs:track :from) (Path:join :dir :to)) :headers
        ]
        header-dirs = Array:from <| Iter:flatten [[:header-dir], :header-dirs]
        includes = to-includes :header-dirs
        compile-flags = compile-flags context:extra

        # Create map from header path to dependency
        uses-header-deps = !(:uses | Iter:map (fn :m -> m:header-deps) | Iter:filter (fn :a -> :a) | Iter:flatten | Map:from)
        mod-header-deps = Iter:map-all (fn (MapEntry: :to :from) -> MapEntry: (path-to-include :to) (set-file-deps context:toolchain :from [-I,:header-dir] :compile-flags :uses-header-deps)) :headers
        header-deps = !Map:from <| Iter:flatten [:uses-header-deps,:mod-header-deps]

        objects = Iter:map-all (fn :f -> compile context:toolchain context:project-root (set-file-deps context:toolchain :f [] :compile-flags :header-deps) :includes ^:compile-flags) :files

        impl = Array:from <| Iter:unique <| Iter:flatten [
            Iter:map (fn :m -> m:impl) :uses | Iter:flatten
            :objects
        ]
        runtime = Array:from <| Iter:unique <| Iter:flatten <| Iter:flatten [
            Iter:map (fn :m -> m:runtime) :uses
            Iter:map (fn :m -> m:runtime-if-used) :uses | Iter:filter (fn :a -> :a)
        ]
        { impl, header-dirs, header-deps, runtime }
    }
}

propagate-flags = fn {compile-flags,link-flags} :context -> {
    extra-compile-flags = !if :compile-flags (compile-flags context:extra) []
    extra-link-flags = !if :link-flags (link-flags context:extra) []
    {
        ^:context,
        toolchain = {
            ^context:toolchain
            compile-flags = [^context:toolchain:compile-flags, ^:extra-compile-flags]
            link-flags = [^context:toolchain:link-flags, ^:extra-link-flags]
        }
    }
}

## Flag a string as being an exact name, so that no target-specific rules are applied.
exact-name = {
    key = "ergo-cpp:exact-name"
    :arg -> !match :arg ^[
        fn :name -> meta:set :name :key true
        pat :out -> :name -> if (!true = meta:get :name :key) { !:out = :name } (!error:throw (pattern=()) "not an exact-name")
    ]
}

## Link a module.
link = fn :name (Module: :mod) :additional-flags :type :include-headers -> {
    Module: <| fn :context -> {
        out = Path:new:
        file = Path:join :out :name

        mod = mod :context

        start-group-flag = !match context:toolchain:target:os ^[
            linux -> ["-Wl,--start-group"]
            _     -> []
        ]

        end-group-flag = !match context:toolchain:target:os ^[
            linux -> ["-Wl,--end-group"]
            _     -> []
        ]

        file = cache <| seq ^[
            fs:create-dir :out
            run (String:format "linking {} {}" :type :name) (env = { PATH = env:get PATH }) context:toolchain:compiler ^context:toolchain:link-flags ^:additional-flags -o :file ^:start-group-flag ^mod:impl ^:end-group-flag
            :file
        ]
        {
            file
            impl = [:file,^mod:runtime]
            runtime = mod:runtime
            runtime-if-used = [:file]
            ^!if :include-headers { import {header-deps,header-dirs} = :mod } {}
        }
    }
}

rename = fn :context :f :name -> !match :name ^[
    exact-name :name -> :name
    :name -> context:toolchain:target::f :name
]

## Create an executable module from a module.
##
## Arguments: `(Map :config)`
##
## The `config` includes:
## * `String :name` - the name of the executable
## * `Module :mod` - the module to make into an executable
## * `optional (Function :compile-flags)` - the compile flags generating function
## * `optional (Function :link-flags)` - the link flags generating function
exe = fn {
    name = String :name
    module = Module :module
    compile-flags = optional (Function :compile-flags)
    link-flags = optional (Function :link-flags)
} -> {
    flags = {compile-flags, link-flags}
    Module: <| fn :context -> {
        context = propagate-flags :flags :context
        Module: :mod = link (rename :context exe-name :name) :module [] executable Bool:false
        ret = mod :context
        {
            ^:ret
            exec = fn ^:args ^{runtime-uses = default :rt-uses as [], ^:kwargs} -> {
                runtime = Iter:flatten [ret:runtime, Iter:map (fn :m -> m:runtime) :rt-uses | Iter:flatten]
                libpath = cache <| Path:with-output <| fn :libpath -> seq ^[
                    fs:create-dir :libpath # Ensure path exists if empty
                    !Array:from <| Iter:map (fn :f -> fs:copy :f :libpath) :runtime
                ]
                exec ^{ ^:kwargs, env = { ^default kwargs:env as {}, ^(context:toolchain:target:lib-path-env :libpath) } } ret:file ^:args
            }
        }
    }
}

## Create a dynamic library module from a module.
##
## Arguments: `(Map :config)`
##
## The `config` includes:
## * `String :name` - the name of the library
## * `Module :mod` - the module to make into a library
## * `optional (Function :compile-flags)` - the compile flags generating function
## * `optional (Function :link-flags)` - the link flags generating function
dynamic-library = fn {
    name = String :name
    module = Module :module
    compile-flags = default (Function :compile-flags) as (fn _ -> [])
    link-flags = optional (Function :link-flags)
} -> {
    # Must always have -fPIC when compiling code in a shared library.
    flags = {
        compile-flags = fn :e -> [^compile-flags :e,-fPIC]
        link-flags
    }
    Module: <| fn :context -> {
        context = propagate-flags :flags :context
        Module: :mod = link (rename :context dynamic-library-name :name) :module [-shared] "dynamic library" Bool:true
        mod :context
    }
}

## Create a static library module from a module.
##
## Arguments: `(Map :config)`
##
## The `config` includes:
## * `String :name` - the name of the library
## * `Module :mod` - the module to make into a library
## * `optional (Function :compile-flags)` - the compile flags generating function
## * `optional (Function :link-flags)` - the link flags generating function
static-library = fn {
    name = String :name
    module = Module: :mod
    compile-flags = optional (Function :compile-flags)
    link-flags = optional (Function :link-flags)
} -> {
    flags = {compile-flags,link-flags}
    Module: <| fn :context -> {
        dir = Path:new:
        filename = rename :context static-library-name :name
        file = Path:join :dir :filename
        mod = mod <| propagate-flags :flags :context

        file = cache <| seq ^[
            fs:create-dir :dir
            run (String:format "creating static library {}" :filename) context:toolchain:archiver -crs :file ^mod:impl
            :file
        ]
        { file, impl = [:file], runtime = mod:runtime, header-dirs = mod:header-dirs, header-deps = mod:header-deps }
    }
}

## Get the output of a Module, using the given configuration map.
##
## Arguments: `(Map :config) (Module :mod)`
##
## The `config` includes:
## * `Path project-root` (required) - the project root directory, in which all source files to be
##   compiled must exist. This is used so debug info can contain the relative directories of the
##   files.
## * `toolchain` - the toolchain to use, using the default toolchain if unspecified.
## 
## All additional values in the configuration map will be passed (as a map) to `compile-flags` and
## `link-flags` functions in other functions, if specified.
get-output = fn {
    project-root = Path :project-root
    toolchain = optional (Map :tc)
    ^:extra
} (Module: :mod) -> {
    toolchain = !if :tc :tc (toolchain {})
    mod {project-root, toolchain, extra}
}

## The ergo-cpp library.
##
## To compile and link c++ code, this library abstracts groups of files and their header interfaces
## into _modules_. A single module represents compiled code and interfaces to it, but modules do not
## compile the code until necessary. Libraries and executables are also considered modules, and
## modules can depend on other modules. To evaluate a module (thus creating it concretely), use
## `get-output` with the configuration you desire.
##
## # Modules
## {{doc:modules :self type}}
##
## # Functions
## {{(doc:functions :self module all-files header-paths
##    exe dynamic-library static-library exact-name
##    get-output toolchain env-toolchain)}}
{
    ## Types used in the library values.
    ##
    ## # Types
    ## {{doc:modules :self Module}}
    type = {Module}
    module
    exe
    dynamic-library
    static-library
    get-output
    toolchain
    env-toolchain
    all-files
    header-paths
    exact-name
}
