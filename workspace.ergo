# The c++ module provides an abstraction over c++ compilation and linking.
# This module assumes binaries that are compatible with gcc flags (typically gcc and clang).

^std:

log = log sublog c++

script-dir = script:dir:

## Return the value of an environment variable, or an alternative value if not set.
env-or = fn :name :alternative -> default (env:get :name) as :alternative

## Run an executable as a task (counting as one task).
run = fn :description ^:args ^{^:kwargs} -> task ^{task-count = 1} :description (exec ^:args ^:kwargs):complete

## Parse space-separated flags from an environment variable, if set.
parse-env-flags = fn :var -> {
    strs = String:split " " (env-or :var "")
    Array:from <| Iter:filter (fn :v -> !match :v ("" -> Bool:false) (_ -> Bool:true)) :strs
}

# TODO divorce the linking/native/binutils stuff from c/c++, separate c and c++ into separate
# libraries

## Create a toolchain from the given configuration.
##
## Arguments: `(Map :config)`
## 
## The `config` may contain the following optional keys:
## * `compiler` - The compiler to use (as a binary name or path), defaulting to `c++`.
## * `c-compiler` - The C compiler to use (as a binary name or path), defaulting to `cc`.
## * `archiver` - The archiver to use (as a binary name or path), defaulting to `ar`.
## * `object-dump` - The tool to inspect generated object files (as a binary or path), defaulting to
##   `objdump`.
## * `compile-flags` - Flags to always pass to `compiler` when compiling source code.
## * `c-compile-flags` - Flags to always pass to `c-compiler` when compiling C source code.
## * `link-flags` - Flags to always pass to `compiler` when linking compiled code.
##
## The returned toolchain is a map with the following keys:
## * `compiler` - The resolved C++ compiler
## * `c-compiler` - The resolved C compiler
## * `archiver` - The resolved archiver program
## * `object-dump` - The resolved object-dump program
## * `compile-flags` - The compile flags to use with the C++ compiler
## * `c-compile-flags` - The compile flags to use with the C compiler
## * `link-flags` - The link flags to use when linking
## * `target` - A map containing the following target-specific keys:
##   * `architecture` - The toolchain target architecture (`arm`, `aarch64`, `i386`, `x86_64`,
##   `unknown`)
##   * `os` - The toolchain target operating system (`windows`, `linux`, `ios-simulator`, `ios`,
##   `macos`, `unknown`)
##   * `compiler` - The type of the toolchain compiler (`clang`, `gcc`, `msvc`, `unknown`)
##   * `c++lib` - The type of the toolchain's C++ library (`libstdc++`, `libc++`, `msvc`, `unknown`)
##   * `c++abi` - The target ABI of the toolchain (`c++11`, `c++03`)
##   * `lib-path-env` - A function that returns the env to set to add a Path to the library search
##   path.
##   * `preload-libraries` - A function that returns the env to set to add a list of library Paths
##   to the preloaded libraries.
##   * `static-library-name` - A function that returns the filesystem name for a particular static
##   library name.
##   * `dynamic-library-name` - A function that returns the filesystem name for a particular dynamic
##   library name.
##   * `exe-name` - A function that returns the filesystem name for a particular executable name.
toolchain = fn {
    compiler = default :compiler as c++
    c-compiler = default :c-compiler as cc
    archiver = default :archiver as ar
    object-dump = default :object-dump as objdump
    compile-flags = default :compile-flags as []
    c-compile-flags = default :c-compile-flags as []
    link-flags = default :link-flags as []
} -> {
    compiler = env:path-search :compiler
    c-compiler = env:path-search :c-compiler
    archiver = env:path-search :archiver
    object-dump = env:path-search :object-dump

    detect = fn :filename -> {
        result = cache {
            file = Path:join :script-dir detection :filename
            output = exec (env = { PATH = env:get PATH }) :compiler ^:compile-flags -imacros cassert -E -P :file |>:stdout
            String:from :output | String:trim | String:split "\"" |>:1
        }
        !log debug <| String:format "detection file `{}` yielded `{}`" :filename :result
        by-content :result
    }

    {
        compiler
        c-compiler
        archiver
        object-dump
        compile-flags
        c-compile-flags
        link-flags
        target = {
            architecture = detect arch.h
            os = detect os.h
            compiler = detect compiler.h
            c++lib = detect cpplib.h

            c++abi = !match :c++lib ^[
                libstdc++ -> detect gnu_abi.h
                _         -> c++11
            ]

            ## Get the environment variables that should be set to add a path to the library lookup path.
            lib-path-env = !match :os ^[
                macos -> fn :path -> { DYLD_LIBRARY_PATH = :path }
                ios   -> fn :path -> { DYLD_LIBRARY_PATH = :path }
                linux -> fn :path -> { LD_LIBRARY_PATH = :path }
                _     -> fn :path -> { PATH = :path }
            ]

            ## Get the environment variables that should be set to preload an array of libraries.
            ##
            ## Arguments: `(Array:Of :Path |> :libs)`
            preload-libraries = !match :os ^[
                macos -> fn :libs -> { DYLD_INSERT_LIBRARIES = String:join ":" <| Iter:map (Function:partial String:format "{}") :libs }
                ios -> fn :libs -> { DYLD_INSERT_LIBRARIES = String:join ":" <| Iter:map (Function:partial String:format "{}") :libs }
                linux -> fn :libs -> { LD_PRELOAD = String:join ":" <| Iter:map (Function:partial String:format "{}") :libs }
                _ -> fn _ -> {}
            ]

            ## Get the filename for a static library with the given name.
            static-library-name = !match :os ^[
                windows -> fn :name -> String:format "{}.lib" :name
                _       -> fn :name -> String:format "{}.a" :name
            ]

            ## Get the filename for a dynamic library with the given name.
            dynamic-library-name = !match :os ^[
                windows -> fn :name -> String:format "{}.dll" :name
                linux   -> fn :name -> String:format "lib{}.so" :name
                macos   -> fn :name -> String:format "lib{}.dylib" :name
                ios     -> fn :name -> String:format "lib{}.dylib" :name
                _       -> fn :name -> :name
            ]

            ## Get the filename for an executable with the given name.
            exe-name = !match :os ^[
                windows -> fn :name -> String:format "{}.exe" :name
                _       -> fn :name -> :name
            ]
        }
    }
}

## Get a toolchain based on the environment.
##
## Arguments: (none)
## 
## This toolchain is derived from the environment variables `CXX`, `CC`, `AR`, `CXXFLAGS`, `CFLAGS`, `LDFLAGS`, and `OBJDUMP`.
## If `CXX` is not set, `c++` is used.
## If `CC` is not set, `cc` is used.
## If `AR` is not set, `ar` is used.
## If `OBJDUMP` is not set, `objdump` is used.
env-toolchain = fn: -> toolchain {
    compiler = env-or CXX c++
    c-compiler = env-or CC cc
    archiver = env-or AR ar
    object-dump = env-or OBJDUMP objdump
    compile-flags = parse-env-flags CXXFLAGS
    c-compile-flags = parse-env-flags CFLAGS
    link-flags = parse-env-flags LDFLAGS
}

cached-path = fn :file-content-cache :path :depends -> {
    if :file-content-cache [:path,:cache] {
        # We want the path to be explicitly cached on the deps.
        out = cache <| variable ^{ depends } :path
        get-value = fn :v -> {
            last-writer-file = cache <| variable (depends = [last-writer, :out]) Path:new:
            me = by-content <| String:from <| cache <| variable (depends = :v) Path:new:
            last-writer = by-content <| String:from (!if (fs:exists :last-writer-file) (fs:read :last-writer-file) "")
            # Shortcut and return `out` if the last writer was this value.
            # The returned value should have the same identity as `v`
            variable (depends = :v) <| if (!:me = :last-writer) :out (seq (fs:write :last-writer-file :me) :v)
        }
        [:out,:get-value]
    }
}

## Compile a file with the given flags.
## The project-root argument is used to ensure the file paths in compiled debug sections are user-friendly.
compile = fn ^{ file-content-cache } :toolchain :project-root :file :untracked-flags ^:flags -> {
    proj-path = !Path:relative :project-root :file
    out = Path:join Path:new: <| String:format "{}.o" :proj-path

    [:out,:ocache] = cached-path :file-content-cache :out [:proj-path, toolchain:compiler, toolchain:compile-flags, :flags]

    {
        object = ocache <| seq ^[
            fs:create-dir <| Path:parent :out
            run (String:format "compiling {}" :file) (env = { PATH = env:get PATH }) toolchain:compiler ^toolchain:compile-flags -c -o :out ^(variable :untracked-flags) ^:flags :file
            :out
        ]
        compile-command = {
            arguments = Array:from <| Iter:map String:from <| Iter:flatten [[toolchain:compiler], toolchain:compile-flags, [-c,-o,:out], variable :untracked-flags, :flags, [:file]]
            file
            out
        }
    }
}

## Convert an array of header directories to include arguments for the compiler.
to-includes = fn :header-dirs -> {
    :header-dirs | Iter:map (fn :d -> [-I,:d]) | Iter:flatten | Array:from
}

## The Module type.
##
## Internally, the type holds a function which, when applied to a _context_, yields some result.
Module = type:new (bind = _ -> _ -> !error:throw "cannot directly access Module") "ergo-cpp:Module" <| match:value ^[
    fn (Function :f) -> Function:memoize :f
    pat :out -> :f -> { !:out = :f }
]

## Return a file path that depends on all include dependencies, given a map of header paths to dependencies
## that will be used for includes that do not resolve to a file.
set-file-deps = fn ^{ banned-headers } :toolchain :file :untracked-compile-flags :compile-flags :known-headers -> {
    deps = String:from (exec (env = { PATH = env:get PATH }) toolchain:compiler ^toolchain:compile-flags -DERGO_CPP_HEADER_DEPENDS -MM -MG ^:untracked-compile-flags ^:compile-flags :file):stdout | String:trim
    # String:regex
    parts = Array <| match (String:split ":" :deps) ([_,^:parts] -> :parts)
    # Split on continuation newlines from make syntax
    parts = Iter:map (fn :p -> String:split "\\\n" :p) :parts | Iter:flatten
    # Split on spaces (XXX this will break on filenames with spaces)
    parts = Iter:map (fn :p -> String:split " " :p) :parts | Iter:flatten
    # Remove empty parts
    parts = Iter:filter (fn :v -> !match :v ("" -> Bool:false) (_ -> Bool:true)) :parts
    # Cache based on the file, compiler, and compile flags
    parts = cache <| variable (depends = [file-deps, fs:track :file, toolchain:compiler, toolchain:compile-flags, :compile-flags]) :parts
    # existing files depend on the result of fs:track, otherwise look in known-headers
    banned-check = !if :banned-headers (fn :x -> !if banned-headers::x { !error:throw <| String:format "private include ({}) used in public header {}" :x :file }) (fn _ -> ())
    depends = !Iter:map (fn :dep -> {
        !if (fs:exists <| Path:join :dep) (fs:track :dep) {
            !match known-headers:(!:dep) ^[
                Unset _ -> banned-check !:dep
                Function:pass
            ]
        }
    }) :parts
    variable ^{ depends } :file
}


ByContent = pat :tgt -> :v -> {!:tgt = by-content :v}

## Get `files` in the current script directory.
##
## The return value is suitable to be passed directly as the `files` key in the `module`
## configuration.
all-files = fn: -> fs:glob *.cpp

## Get `headers` from a heirarchical description.
##
## Arguments: `:descr`
##
## `decr` may be one of:
## * `all` to get all headers in the current script directory,
## * an `Array` of files, or
## * a `Map` where keys are the `#include` path components and values are
##   recursively evaluated as `descr`.
##
## The return value is suitable to be passed directly as the `headers` key in the `module`
## configuration.
header-paths = {
    inner = Function:recursive <| fn :self :descr -> {
        !match :descr ^[
            String (ByContent all) -> Iter:map (fn :a -> MapEntry: (by-content (Path:join (Path:name :a))) :a) <| fs:glob *.h
            [^:files] -> Iter:map (fn :a -> MapEntry: (by-content (Path:join (Path:name (Path:join :a)))) (Path:join :dir :a)) :files
            {^:dirs} -> {
                Iter:flatten <| Iter:map (fn (MapEntry: :key :val) -> {
                    paths = self :self :val
                    key = Path:join ^(String:split / :key)
                    Iter:map (fn (MapEntry: :to :from) -> MapEntry: (by-content <| Path:join :key :to) :from) :paths
                }) :dirs
            }
        ]
    }
    fn :descr -> Map:from <| inner :descr
}

## Convert a path to an include string.
path-to-include = fn :p -> by-content <| String:join "/" <| Path:split :p

modules = Array:Of :Module
match-uses = pat :tgt -> match:value ^[
    { private = default (modules :private) as []
      public = default (modules :public) as []
      export = default (modules :export) as []
    } -> {
        !:tgt = { private, public, export }
    }

    default (modules :uses) as [] -> { !:tgt = { private = :uses, public = [], export = [] } }
]

vis = {
    map = fn (Function :f) :v -> {
        private = f v:private
        public = f v:public
        export = f v:export
    }
    internal = fn :v -> Iter:flatten [v:public, v:private]
    external = fn :v -> Iter:flatten [v:public, v:export]
    all = fn :v -> Iter:flatten [v:public, v:private, v:export]
    eval = fn :v -> {
        internal = internal :v
        external = external :v
    }
    map* = fn (Function :f) :v -> {
        internal = f v:internal
        external = f v:external
    }
}

## Evaluate uses with a context.
##
## Arguments: `:context :uses`
##
## `context` should be the module context.
## `uses` should be the output of a `match-uses` binding, specifically a map of
## private/public/export uses modules.
##
## Returns a map with:
## * `uses` - all uses outputs
## * `header-dirs` - a map of internal/external header-dirs
## * `header-deps` - a map of internal/external header-deps
eval-uses = fn :context :uses -> {
    uses = vis:map (Function:partial Iter:map-all (fn (Module: :u) -> u :context)) :uses
    int-ext = vis:eval :uses
    uses-header-dirs = vis:map* (fn :uses -> (:uses | Iter:map (fn :m -> m:header-dirs) | Iter:flatten | Iter:unique)) :int-ext
    uses-header-deps = vis:map* (fn :uses -> !(:uses | Iter:map (fn :m -> m:header-deps) | Iter:filter (fn :a -> :a) | Iter:flatten | Map:from)) :int-ext
    {
        uses = vis:all :uses, 
        header-dirs = :uses-header-dirs
        header-deps = :uses-header-deps
    }
}

module-result = fn :all-uses { impl, runtime, compile-commands, header-dirs, header-deps, ^:rest } -> {
    impl = Array:from <| Iter:unique <| Iter:flatten [
        Iter:map (fn :m -> m:impl) :all-uses | Iter:flatten
        :impl
    ]
    runtime = Array:from <| Iter:unique <| Iter:flatten <| Iter:flatten [
        Iter:map (fn :m -> m:runtime) :all-uses
        Iter:map (fn :m -> m:runtime-if-used) :all-uses | Iter:filter (fn :a -> :a)
        :runtime
    ]
    compile-commands = Array:from <| Iter:unique <| Iter:flatten [
        Iter:flatten (:all-uses | Iter:map (fn :u -> u:compile-commands) | Iter:filter (fn :a -> :a))
        :compile-commands
    ]

    { impl, header-dirs = header-dirs:external, header-deps = header-deps:external, runtime, compile-commands, ^:rest }
}

## Create a module with the given configuration.
##
## Arguments: `(Map :config)`
## 
## The configuration should be a map with the following optional keys:
## * `files`: an array of the files to compile
## * `headers`: a map with the headers to expose, where the key is the `#include` Path and the value
##   is the header file Path.
## * `uses`: the modules to use with this module, either an array (with private visibility) or a map
##   with the following optional keys:
##   * `public`: an array of modules which will be used when compiling files in this module
##     and will be visible to consumers of this module.
##   * `private`: an array of modules which will be used when compiling files in this module.
##   * `export`: an array of modules which will be visible to consumers of this module.
## * `compile-flags`: additional compilation flags to use when compiling files in this module
##   This should be a function which is passed the extra context and returns an array of flags.
## 
## In both files and headers, if a file is a relative path, it will be relative to the calling
## script directory. To set the relative path explicitly, pass the keyword argument `relative-dir`.
## 
## The returned value will be a Module, where the output will be a map with the following keys:
## * `impl`: an array of compiled object files
## * `header-dirs`: an array of header directories exported by the module (and all directories from used modules)
## * `header-deps`: a map from header paths to the file to which they resolve
##   (where the file value also incorporates all header dependencies when deriving
##   its identity)
## * `runtime`: an array of any additional requirements of the module (inherited from used modules)
## * `compile-commands`: an array of compile commands to build the module and all dependent modules
module = fn ^{ relative-dir } {
    files = default (Array :files) as []
    headers = default (Map :headers) as {}
    uses = match-uses :uses
    compile-flags = default (Function :compile-flags) as (fn _ -> [])
} -> {
    dir = default :relative-dir as script:dir:

    files = Iter:map (fn :f -> Path:join :dir :f) :files
    headers = Iter:map (fn (MapEntry: :to :from) -> MapEntry: :to (Path:join :dir :from)) :headers

    Module: <| fn :context -> {
        evaled = eval-uses :context :uses

        header-dir = cache <| Path:with-output <| fn :dir -> seq ^[
            fs:create-dir :dir # Ensure path exists if empty
            # Force the array so the inner values are the results of `fs:copy`, which will include
            # the `fs:track` identities (so if a header changes, the header-dir is rebuilt).
            !Array:from <| Iter:map-all (fn (MapEntry: :to :from) -> fs:copy (fs:track :from) (Path:join :dir :to)) :headers
        ]

        header-dirs = vis:map* (fn :header-dirs -> Array:from <| Iter:flatten [[:header-dir], :header-dirs]) evaled:header-dirs

        includes = to-includes header-dirs:internal
        compile-flags = compile-flags context:extra

        # headers should have file-deps based on the external `uses` header-deps to ensure no headers depends on internal uses 
        # ban internal header-deps so that if they are used, an error will occur about exposing a private module
        mod-header-deps = Iter:map-all (fn (MapEntry: :to :from) -> {
            MapEntry: (path-to-include :to) (
                set-file-deps (banned-headers = evaled:header-deps:internal)
                    context:toolchain :from [-I,:header-dir] :compile-flags evaled:header-deps:external
                )
        }) :headers
        header-deps = vis:map* (fn :uses-header-deps -> !Map:from <| Iter:flatten [:uses-header-deps,:mod-header-deps]) evaled:header-deps

        compiles = Iter:map-all (fn :f -> compile (file-content-cache = context:options:file-content-cache) context:toolchain context:project-root (set-file-deps context:toolchain :f [] :compile-flags header-deps:internal) :includes ^:compile-flags) :files
        objects = Iter:map-all (fn :c -> c:object) :compiles
        compile-commands = Iter:map-all (fn :c -> c:compile-command) :compiles

        module-result evaled:uses { impl = :objects, runtime = [], compile-commands, header-dirs, header-deps }
    }
}

## Create a module that is already compiled with the given configuration.
##
## Arguments: `(Map :config)`
## 
## The configuration should be a map with the following optional keys:
## * `Array :link` - object files/libraries to link
## * `(Array:Of :Path) :include-dirs` - include directories
## * `(Array:Of :Path) :runtime` - libraries (typically dynamic) needed at runtime
## * `(Map :header-deps)` - a map from include path to header file path, which helps in resolving header dependencies
## * `Array :compile-commands` - an array of compile commands that are used to produce the module,
##   where items are maps with:
##   * `Array :arguments` - the arguments in the compile command (including executable)
##   * `Path :file` - the input file of the command (absolute path)
##   * `Path :out` - the output file of the command (absolute path)
## * `uses`: the modules to use with this module, either an array (with private visibility) or a map
##   with the following optional keys:
##   * `public`: an array of modules which will be used when compiling files in this module
##     and will be visible to consumers of this module.
##   * `private`: an array of modules which will be used when compiling files in this module.
##   * `export`: an array of modules which will be visible to consumers of this module.
##
##  Any additional keys in the config map will be copied in the module result.
## 
## The returned value will be a Module, where the output will be a map with the following keys:
## * `impl`: an array of compiled object files
## * `header-dirs`: an array of header directories exported by the module (and all directories from used modules)
## * `header-deps`: a map from header paths to the file to which they resolve
##   (where the file value also incorporates all header dependencies when deriving
##   its identity)
## * `runtime`: an array of any additional requirements of the module (inherited from used modules)
## * `compile-commands`: an array of compile commands to build the module and all dependent modules
## * additional keys from the config map
compiled-module = fn {
    link = default (Array :link) as []
    include-dirs = default (Array:Of :Path |> :includes) as []
    runtime = default (Array:Of :Path |> :runtime) as []
    header-deps = default (Map :header-deps) as {}
    compile-commands = default (Array :compile-commands) as []
    uses = match-uses :uses
    ^:rest
} -> {
    Module: <| fn :context -> {
        evaled = eval-uses :context :uses
        header-dirs = vis:map* (fn :header-dirs -> Array:from <| Iter:flatten [:includes, :header-dirs]) evaled:header-dirs
        header-deps = vis:map* (fn :uses-header-deps -> !Map:from <| Iter:flatten [:uses-header-deps, :header-deps]) evaled:header-deps

        module-result evaled:uses { impl = :link, runtime, compile-commands, header-dirs, header-deps, ^:rest }
    }
}

propagate-flags = fn {compile-flags,link-flags} :context -> {
    extra-compile-flags = !if :compile-flags (compile-flags context:extra) []
    extra-link-flags = !if :link-flags (link-flags context:extra) []
    {
        ^:context,
        toolchain = {
            ^context:toolchain
            compile-flags = [^context:toolchain:compile-flags, ^:extra-compile-flags]
            link-flags = [^context:toolchain:link-flags, ^:extra-link-flags]
        }
    }
}

## Flag a string as being an exact name, so that no target-specific rules are applied.
exact-name = {
    key = "ergo-cpp:exact-name"
    :arg -> !match :arg ^[
        fn :name -> meta:set :name :key true
        pat :out -> :name -> if (!true = meta:get :name :key) { !:out = :name } (!error:throw (pattern=()) "not an exact-name")
    ]
}

## Link a module.
link = fn :call-site :name (Module: :mod) :additional-flags :type :include-headers -> {
    Module: <| fn :context -> {
        mod = mod :context

        start-group-flag = !match context:toolchain:target:os ^[
            linux -> ["-Wl,--start-group"]
            _     -> []
        ]

        end-group-flag = !match context:toolchain:target:os ^[
            linux -> ["-Wl,--end-group"]
            _     -> []

        ]

        call-site = call-site :context

        file = Path:join Path:new: :call-site :name

        [:file,:fcache] = cached-path context:options:file-content-cache :file [:call-site, :name, context:toolchain:compiler, context:toolchain:link-flags, :additional-flags]

        file = fcache <| seq ^[
            fs:create-dir <| Path:parent :file
            run (String:format "linking {} {}" :type :name) (env = { PATH = env:get PATH }) context:toolchain:compiler ^context:toolchain:link-flags ^:additional-flags -o :file ^:start-group-flag ^mod:impl ^:end-group-flag
            :file
        ]

        {
            file
            impl = [:file,^mod:runtime]
            runtime = mod:runtime
            runtime-if-used = [:file]
            ^!if :include-headers { import {header-deps,header-dirs} = :mod } {}
            compile-commands = mod:compile-commands
        }
    }
}

rename = fn :context :f :name -> !match :name ^[
    exact-name :name -> :name
    :name -> context:toolchain:target::f :name
]

call-site = fn: -> {
    p = !error:catch (fn _ -> script:dir:) (dynamic script:path):
    fn :context -> !Path:relative context:project-root :p
}

## Create an executable module from a module.
##
## Arguments: `(Map :config)`
##
## The `config` includes:
## * `String :name` - the name of the executable
## * `Module :mod` - the module to make into an executable
## * `optional (Function :compile-flags)` - the compile flags generating function
## * `optional (Function :link-flags)` - the link flags generating function
exe = fn {
    name = String :name
    module = Module :module
    compile-flags = optional (Function :compile-flags)
    link-flags = optional (Function :link-flags)
} -> {
    flags = {compile-flags, link-flags}
    site = call-site:
    Module: <| fn :context -> {
        context = propagate-flags :flags :context
        Module: :mod = link :site (rename :context exe-name :name) :module [] executable Bool:false
        mod :context
    }
}

## Create a dynamic library module from a module.
##
## Arguments: `(Map :config)`
##
## The `config` includes:
## * `String :name` - the name of the library
## * `Module :mod` - the module to make into a library
## * `optional (Function :compile-flags)` - the compile flags generating function
## * `optional (Function :link-flags)` - the link flags generating function
dynamic-library = fn {
    name = String :name
    module = Module :module
    compile-flags = default (Function :compile-flags) as (fn _ -> [])
    link-flags = optional (Function :link-flags)
} -> {
    # Must always have -fPIC when compiling code in a shared library.
    flags = {
        compile-flags = fn :e -> [^compile-flags :e,-fPIC]
        link-flags
    }
    site = call-site:
    Module: <| fn :context -> {
        context = propagate-flags :flags :context
        Module: :mod = link :site (rename :context dynamic-library-name :name) :module [-shared] "dynamic library" Bool:true
        mod :context
    }
}

## Create a static library module from a module.
##
## Arguments: `(Map :config)`
##
## The `config` includes:
## * `String :name` - the name of the library
## * `Module :mod` - the module to make into a library
## * `optional (Function :compile-flags)` - the compile flags generating function
## * `optional (Function :link-flags)` - the link flags generating function
static-library = fn {
    name = String :name
    module = Module: :mod
    compile-flags = optional (Function :compile-flags)
    link-flags = optional (Function :link-flags)
} -> {
    flags = {compile-flags,link-flags}
    site = call-site:
    Module: <| fn :context -> {
        mod = mod <| propagate-flags :flags :context

        site = site :context
        filename = rename :context static-library-name :name
        file = Path:join Path:new: :site :filename

        [:file,:fcache] = cached-path context:options:file-content-cache :file [:site, :filename, context:toolchain:archiver]

        file = fcache <| seq ^[
            fs:create-dir <| Path:parent :file
            run (String:format "creating static library {}" :filename) context:toolchain:archiver -crs :file ^mod:impl
            :file
        ]
        {
            file
            impl = [:file]
            runtime = mod:runtime
            header-dirs = mod:header-dirs
            header-deps = mod:header-deps
            compile-commands = mod:compile-commands
        }
    }
}

## Get the output of a Module, using the given configuration map.
##
## Arguments: `(Map :config) (Module :mod)`
##
## The `config` includes:
## * `Path project-root` (required) - the project root directory, in which all source files to be
##   compiled must exist. This is used so debug info can contain the relative directories of the
##   files.
## * `toolchain` - the toolchain to use, using the default toolchain if unspecified.
## * `options` - a map of options affecting behavior, including:
##   * `file-content-cache` - if present, outputs will be cached based on file content in addition
##     to the compile flags. For example, if you compile, change a file, compile again, and then
##     revert the change, no recompilation will occur because there will already be a compiled
##     output in the cache. This is most useful if switching between branches/commits often.
##
## Note that if `file-content-cache` is not specified, `exe`/`dynamic-library`/`static-library`
## outputs _must_ have unique names on a per-script basis. This is because the caching relies on the
## script path and name when determining the cache target file.
## 
## All additional values in the configuration map will be passed (as a map) to `compile-flags` and
## `link-flags` functions in other functions, if specified.
get-output = fn {
    project-root = Path :project-root
    toolchain = optional (Map :tc)
    options = default (Map :options) as {}
    ^:extra
} (Module: :mod) -> {
    toolchain = !if :tc :tc (toolchain {})
    mod {project-root, toolchain, options, extra}
}

string-escape = fn :s -> {
    s = String:join "\\\"" <| String:split "\"" :s
    s = String:join "\\\\" <| String:split "\\" :s
    :s
}

## Create a compile_commands.json file for all compile commands in the outputs.
##
## Arguments: `^:outputs`
##
## The outputs should be obtained with `get-output`.
##
## Returns a Path to a compile_commands.json file.
compile-commands = fn ^:outputs -> {
    path = Path:new:
    file = Path:join :path compile_commands.json
    to-entry = fn { arguments, file, out } -> {
        args = String:join "," <| Iter:map (fn :a -> String:format "\"{}\"" <| string-escape :a) :arguments
        String:format ^{file, out, args} "{{ \"directory\": \"/\",\n \"file\": \"{file}\",\n \"output\": \"{out}\",\n \"arguments\": [{args}]\n }}"
    }
    commands = Iter:unique <| Iter:flatten <| Iter:map (fn :o -> o:compile-commands) :outputs
    content = String:format "[{}]" <| String:join ",\n" <| Iter:map :to-entry :commands
    seq (fs:create-dir :path) (fs:write :file :content) :file
}

## Execute an output.
##
## Arguments: `:output ^:args`
##
## Keyword Arguments:
## * `:runtime-uses` - an array of extra module outputs whose runtime should also be used as part of
##   the executable's runtime
## * `^:kwargs` - forwarded to `exec`
##
## The output should be obtained with `get-output`.
## The output must provide an executable `file` key in the result, like `exe` does.
##
## Returns the result of running `exec`.
exec-output = fn :ret ^:args ^{runtime-uses = default :rt-uses as [], ^:kwargs} -> {
    runtime = Iter:flatten [ret:runtime, Iter:map (fn :m -> m:runtime) :rt-uses | Iter:flatten]
    rt-env = !match env:os ^[
        windows -> {
            libpath = cache <| Path:with-output <| fn :libpath -> seq ^[
                fs:create-dir :libpath # Ensure path exists if empty
                !Array:from <| Iter:map (fn :f -> fs:copy :f :libpath) :runtime
            ]
            { PATH = :libpath }
        }
        # Use preloaded libraries when possible; this avoids issues with filenames not
        # matching linked dependency names (from, e.g., SONAME)
        linux -> { LD_PRELOAD = String:join ":" <| Iter:map (Function:partial String:format "{}") :runtime }
        macos -> { DYLD_INSERT_LIBRARIES = String:join ":" <| Iter:map (Function:partial String:format "{}") :runtime }
    ]
    exec ^{ ^:kwargs, env = { ^default kwargs:env as {}, ^:rt-env } } ret:file ^:args
}

## The ergo-cpp library.
##
## To compile and link c++ code, this library abstracts groups of files and their header interfaces
## into _modules_. A single module represents compiled code and interfaces to it, but modules do not
## compile the code until necessary. Libraries and executables are also considered modules, and
## modules can depend on other modules. To evaluate a module (thus creating it concretely), use
## `get-output` with the configuration you desire.
##
## # Modules
## {{doc:modules :self type}}
##
## # Functions
## {{(doc:functions :self module all-files header-paths
##    compiled-module
##    exe dynamic-library static-library exact-name
##    get-output toolchain env-toolchain
##    compile-commands exec-output)}}
{
    ## Types used in the library values.
    ##
    ## # Types
    ## {{doc:modules :self Module}}
    type = {Module}
    module
    compiled-module
    exe
    dynamic-library
    static-library
    get-output
    toolchain
    env-toolchain
    all-files
    header-paths
    exact-name
    compile-commands
    exec-output
}
