# The c++ module provides an abstraction over c++ compilation and linking.
# This module assumes binaries that are compatible with gcc flags (typically gcc and clang).

^(ergo std)

# If the first argument is a truth value, return it, otherwise return the second argument.
unless = fn a b -> if $a $a $b

# Return the value of an environment variable, or an alternative value if not set.
env_or = fn name alternative -> unless (env get $name) $alternative

# Run an executable as a task.
run = fn description ^args ^{^kwargs} -> seq [$args,$kwargs] (task $description (exec ^$args ^$kwargs) complete)

# Get default compiler/flags settings.
compiler = env path-search (string from (env_or CXX c++))
archiver = env path-search (string from (env_or AR ar))
extra-cflags = string split (env_or CXXFLAGS "") " "
extra-lflags = string split (env_or LDFLAGS "") " "

target-os = {
    preproc = "#if defined(_WIN32)
windows
#elif defined(__linux__)
linux
#elif defined(__APPLE__)
mac
#else
unsupported
#endif"
    check = exec ^{ stdin = $preproc } $compiler ^$extra-cflags -E -P -
    value force (string trim (string from (check stdout)))
}

static-library-name = fn name -> match $target-os {
    =windows = string format "{}.lib" $name
    _ = string format "{}.a" $name
}

dynamic-library-name = fn name -> match $target-os {
    =windows = string format "{}.dll" $name
    =linux = string format "lib{}.so" $name
    =mac = string format "lib{}.dylib" $name
    _ = $name
}

exe-name = fn name -> match $target-os {
    =windows = string format "{}.exe" $name
    _ = $name
}

# Compile a file with the given flags.
# The project-root argument is used to ensure the file paths in compiled debug sections are user-friendly.
compile = fn project-root file ^flags -> value cache seq ^[
    out = path join (path new) (string format "{}.o" (path relative $project-root $file))
    fs create-dir (path parent $out)
    run (string format "compiling {}" $file) ^{ env = { PATH = $ } } $compiler ^$extra-cflags -o $out ^$flags (fs track $file)
    $out
]

to-includes = fn header-dirs -> fold (fn l dir -> [^$l,-I,$dir]) [] $header-dirs

# Create a module in the given directory (used for auto parameters) with the given configuration.
#
# The configuration may be "auto", which will get all .cpp and .h files as the module contents.
# Otherwise, it should be a map with the following optional keys:
#   files: the files to compile, or "auto"
#   headers: the headers to expose, or "auto"
#   uses: the modules to use with this module
#
# The returned module generator function, when passed a compilation context, will return
# a module output map with the following keys:
#   impl: an array of compiled object files
#   header-dirs: an array of header directories exported by the module (and all directories from used modules)
#   runtime: an array of any additional requirements of the module (inherited from used modules)
module = fn dir config -> {
    config = match $config {
        =auto = { files = auto, headers = auto }
        other = $other
    }
    files = unless (config files) []
    headers = unless (config headers) []
    uses = unless (config uses) []

    files = match (value $files) {
        =auto = value force (fs glob (path join $dir *.cpp))
        other = $other
    }
    headers = match (value $headers) {
        =auto = value force (fs glob (path join $dir *.h))
        other = $other
    }

    fn context -> {
        uses = collection map (fn u -> u $context) $uses
        header-dirs = collection fold (fn l use -> [^$l,^(use header-dirs)]) [] $uses
        includes = to-includes $header-dirs
        objects = map (fn f -> compile (context project-root) $f ^$includes ^(context cflags)) $files
        impl = fold (fn l use -> [^$l,^(use impl)]) $objects $uses
        runtime = fold (fn l use -> [^$l,^(use runtime),^(unless (use runtime-if-used) [])]) [] $uses
        header-dir = value cache seq ^[
            dir = path new
            fs create-dir $dir
            map (fn f -> fs copy (track $f) $dir) $headers
            $dir
        ]
        header-dirs = [$header-dir,^$header-dirs]
        { impl, header-dirs, runtime }
    }
}

# Link a module.
link = fn ^{^kwargs} name mod additional-flags type -> fn context -> cache seq ^[
    out = path new
    fs create-dir $out
    out = path join $out $name
    cflags = if (kwargs cflags) [^(context cflags),^(kwargs cflags)] (context cflags)
    lflags = if (kwargs lflags) [^(context lflags),^(kwargs lflags)] (context lflags)
    mod = mod {project-root = (context project-root), cflags, lflags}
    run (string format "linking {} {}" $type $name) ^{ env = {PATH = $} } $compiler ^$extra-lflags ^$additional-flags ^$lflags -o $out "-Wl,--start-group" ^(mod impl) "-Wl,--end-group"
    { file = $out, impl = [$file], runtime = (mod runtime), runtime-if-used = [$file], header-dirs = (mod header-dirs) }
]

# Link a module into an executable.
exe = fn ^{^kwargs} name mod -> link ^$kwargs (exe-name $name) $mod [] executable

# Link a module into a dynamic library.
dynamic-library = fn ^{^kwargs} name mod -> link ^{ cflags = [], ^$kwargs, cflags = [^$cflags,-fPIC] } (dynamic-library-name $name) $mod [-shared] "dynamic library"

# Link a module into a static library.
static-library = fn ^{cflags} name mod -> fn context -> {
    out = path new
    fs create-dir $out
    filename = static-library-name $name
    out = path join $out $filename
    cflags = if $cflags [^(context cflags),^$cflags] (context cflags)
    mod = mod { ^$context, cflags }
    run (string format "creating static library {}" $filename) $archiver -crs $out ^(mod impl)
    { file = $out, impl = [$file], runtime = (mod runtime), header-dirs = (mod header-dirs) }
}

{
    module
    exe
    dynamic-library
    static-library
    context = fn project-root cflags lflags -> fn t -> t {project-root,cflags,lflags}
}
